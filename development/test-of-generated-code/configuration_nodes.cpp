// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_nodes.cpp
// and it is generated by:      .../test.py[153]
// based on pattern file:       .../patterns/collection.cpp.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#include <sstream>

#include "configuration_nodes.h"
#include "common_conversion_error.h"
#include "configuration_node.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  bool Nodes::operator==(const Nodes& nodes) const noexcept 
  {
    std::vector<Configuration::Node>::const_iterator my_node = m_nodes.begin();
    std::vector<Configuration::Node>::const_iterator other_node = nodes.m_nodes.begin();
    while ( my_node != m_nodes.end() && other_node != nodes.m_nodes.end() )
    {
      if (!( *my_node == *other_node ))
      {
        return false;
      }
      ++my_node;
      ++other_node;
    }
    if (my_node == m_nodes.end() || other_node == nodes.m_nodes.end())
    {
      return true;
    }
    else
    {
      return false;
    }
  }
  
  bool Nodes::operator!=(const Nodes& nodes) const noexcept  
  {
    std::vector<Configuration::Node>::const_iterator my_node = m_nodes.begin();
    std::vector<Configuration::Node>::const_iterator other_node = nodes.m_nodes.begin();
    while ( my_node != m_nodes.end() && other_node != nodes.m_nodes.end() )
    {
      if ( *my_node != *other_node )
      {
        return true;
      }
      ++my_node;
      ++other_node;
    }
    if (my_node == m_nodes.end() || other_node == nodes.m_nodes.end())
    {
      return false;
    }
    else
    {
      return true;
    }
  }
  
  bool Nodes::operator<(const Nodes& nodes) const noexcept 
  {
    std::vector<Configuration::Node>::const_iterator my_node = m_nodes.begin();
    std::vector<Configuration::Node>::const_iterator other_node = nodes.m_nodes.begin();
    while ( my_node != m_nodes.end() && other_node != nodes.m_nodes.end() )
    {
      if ( *my_node < *other_node )
      {
        return true;
      }
      if ( *my_node != *other_node )
      {
        return false;
      }
      ++my_node;
      ++other_node;
    }
    if (my_node == m_nodes.end() || other_node == nodes.m_nodes.end())
    {
      return false;
    }
    else
    {
      if (my_node != m_nodes.end())
      {
         return false;
      }
      else
      {
        return true;
      }
    }
  }
  
  bool Nodes::operator<=(const Nodes& nodes) const noexcept 
  {
    std::vector<Configuration::Node>::const_iterator my_node = m_nodes.begin();
    std::vector<Configuration::Node>::const_iterator other_node = nodes.m_nodes.begin();
    while ( my_node != m_nodes.end() && other_node != nodes.m_nodes.end() )
    {
      if ( *my_node < *other_node )
      {
        return true;
      }
      if ( *my_node != *other_node )
      {
        return false;
      }
      ++my_node;
      ++other_node;
    }
    if (my_node == m_nodes.end() || other_node == nodes.m_nodes.end())
    {
      return true;
    }
    else
    {
      if (my_node != m_nodes.end())
      {
         return false;
      }
      else
      {
        return true;
      }
    }
  }
  
  bool Nodes::operator>=(const Nodes& nodes) const noexcept 
  {
    std::vector<Configuration::Node>::const_iterator my_node = m_nodes.begin();
    std::vector<Configuration::Node>::const_iterator other_node = nodes.m_nodes.begin();
    while ( my_node != m_nodes.end() && other_node != nodes.m_nodes.end() )
    {
      if ( *my_node > *other_node )
      {
        return true;
      }
      if ( *my_node != *other_node )
      {
        return false;
      }
      ++my_node;
      ++other_node;
    }
    if (my_node == m_nodes.end() || other_node == nodes.m_nodes.end())
    {
      return true;
    }
    else
    {
      if (my_node != m_nodes.end())
      {
         return true;
      }
      else
      {
        return false;
      }
    }
  }
  
  bool Nodes::operator>(const Nodes& nodes) const noexcept 
  {
    std::vector<Configuration::Node>::const_iterator my_node = m_nodes.begin();
    std::vector<Configuration::Node>::const_iterator other_node = nodes.m_nodes.begin();
    while ( my_node != m_nodes.end() && other_node != nodes.m_nodes.end() )
    {
      if ( *my_node > *other_node )
      {
        return true;
      }
      if ( *my_node != *other_node )
      {
        return false;
      }
      ++my_node;
      ++other_node;
    }
    if (my_node == m_nodes.end() || other_node == nodes.m_nodes.end())
    {
      return false;
    }
    else
    {
      if (my_node != m_nodes.end())
      {
         return true;
      }
      else
      {
        return false;
      }
    }
  }
  
  void Nodes::removeNode(const Iterator& node)
  {
    m_nodes.erase(node); 
  }
  
  std::string Nodes::SearchResult::toString() const
  {
    std::ostringstream string_representation;
    string_representation << *this;
    return string_representation.str();
  }
  
  std::string Nodes::ConstSearchResult::toString() const
  {
    std::ostringstream string_representation;
    string_representation << *this;
    return string_representation.str();
  }
  
  std::ostream& operator<<(std::ostream& output, const Nodes::SearchResult& nodes)
  {
    output << "[ ";
    const char* separator = "";
    for (std::vector<Configuration::Node::Iterator>::const_iterator node = nodes.m_found_nodes.begin(); node != nodes.m_found_nodes.end(); ++node)
    {
      output << separator << **node;
      separator = ", ";
    }
  
    output << " ]";
    return output;
  }
  
  std::ostream& operator<<(std::ostream& output, const Nodes::ConstSearchResult& nodes)
  {
    output << "[ ";
    const char* separator = "";
    for (std::vector<Configuration::Node::ConstIterator>::const_iterator node = nodes.m_found_nodes.begin(); node != nodes.m_found_nodes.end(); ++node)
    {
      output << separator << **node;
      separator = ", ";
    }
  
    output << " ]";
    return output;
  }
  
  std::string Nodes::toString() const
  {
    std::ostringstream string_representation;
    string_representation << *this;
    return string_representation.str();
  }
  
  std::ostream& operator<<(std::ostream& output, const Nodes& nodes)
  {
    output << "[ ";
    const char* separator = "";
    for (std::vector<Configuration::Node>::const_iterator node = nodes.m_nodes.begin(); node != nodes.m_nodes.end(); ++node)
    {
      output << separator << *node;
      separator = ", ";
    }
  
    output << " ]";
    return output;
  }
  
  Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& serializer, const Nodes& nodes)
  {
    uint16_t count_of_items = nodes.getNodesCount();
    serializer.storeValue(count_of_items);
    for (std::vector<Configuration::Node>::const_iterator node = nodes.m_nodes.begin(); node != nodes.m_nodes.end(); ++node)
    {
      serializer << *node;
    }
    return serializer;
  }
  
  Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& deserializer, Nodes& nodes)
  {
    uint16_t count_of_items = 0;
    deserializer.readValue(count_of_items);
    nodes.m_nodes.clear();
    Configuration::Node node;
    for (uint16_t item_number = 0; item_number < count_of_items; ++item_number)
    {
      deserializer >> node;
      nodes.insertNode(node);
    }
    return deserializer;
  }
  
  // vvv--- YOU CAN PUT ADDITIONAL CODE BELOW
  
  // ^^^--- END OF USER DEFINED CODE

} // end Configuration

// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/common_text_message.h
// and it is generated by:      .../generator.py[108]
// based on pattern file:       .../patterns/string.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <string>
#include <iostream>
#include "common_strcmp_compare.h"
#include "common_conversion_error.h"
#include "serialization_binary_serialization.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Common
{
  class TextMessage
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Common::TextMessage" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      static constexpr uint16_t max_length = { 4000 };
  
      explicit TextMessage(const char* text_message)
      : m_text_message(text_message)
      {  }
  
      explicit TextMessage(std::string&& text_message)
      : m_text_message(text_message)
      {  }
  
      TextMessage() noexcept
      : m_text_message("No comments.")
      {  }
      
      constexpr explicit TextMessage(const std::string& text_message) noexcept
      : m_text_message(text_message)
      {  }
      
      TextMessage(const TextMessage& text_message) noexcept = default;
      TextMessage(TextMessage&& text_message) noexcept = default;
      TextMessage& operator=(const TextMessage& text_message) noexcept = default;
      TextMessage& operator=(TextMessage&& text_message) noexcept = default;
  
      std::string getTextMessageAsString() const noexcept { return m_text_message; }
  
      const TextMessage& getTextMessage() const noexcept { return *this; }
      
      void setTextMessage(const TextMessage& text_message) { *this = text_message; }
      void setTextMessage(const std::string& text_message) { *this = TextMessage(text_message); }
      void setFrom(const TextMessage& text_message) { *this = text_message; }
      void setFrom(TextMessage&& text_message) { *this = text_message; }
      void setTextMessage(const char* text_message) { *this = TextMessage(text_message); }
  
      uint16_t getTextMessageLength() const { return static_cast<uint16_t>(m_text_message.length()); }
  
      bool operator==(const TextMessage& other) const noexcept { return Common::StrcmpCompare::isEqual(this->m_text_message, other.m_text_message); }
      bool operator!=(const TextMessage& other) const noexcept { return Common::StrcmpCompare::isNotEqual(this->m_text_message, other.m_text_message); }
      bool operator<(const TextMessage& other) const noexcept { return Common::StrcmpCompare::isLower(this->m_text_message, other.m_text_message); }
      bool operator<=(const TextMessage& other) const noexcept { return Common::StrcmpCompare::isLowerOrEqual(this->m_text_message, other.m_text_message); }
      bool operator>=(const TextMessage& other) const noexcept { return Common::StrcmpCompare::isAboveOrEqual(this->m_text_message, other.m_text_message); }
      bool operator>(const TextMessage& other) const noexcept { return Common::StrcmpCompare::isAbove(this->m_text_message, other.m_text_message); }
  
      std::string toString() const;
  
      friend std::ostream& operator<<(std::ostream& output, const TextMessage& text_message) { output << text_message.toString(); return output; }
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const TextMessage& text_message);
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, TextMessage& text_message);
  
    private:
      std::string m_text_message;
  
      void checkSize()
      {
        // vvv--- YOU CAN PUT VALUE CHECK HANDLING HERE
        if (getTextMessageLength() > max_length)
        {
          throw Common::ConversionError(m_text_message, "too long string to initiate Common::TextMessage");
        }
        // ^^^--- END OF VALUE CHECK HANDLING HERE
      }
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Common

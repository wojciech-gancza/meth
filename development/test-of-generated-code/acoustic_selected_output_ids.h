// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/acoustic_selected_output_ids.h
// and it is generated by:      .../test.py[66]
// based on pattern file:       .../patterns/bitflags.h.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <string>
#include <iostream>

#include "binary_serialization.h"

namespace Acoustic
{
  class SelectedOutputIds
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Acoustic::SelectedOutputIds" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { false };
      static constexpr bool size_in_bytes = { 1 };
      static constexpr uint8_t first_flag_value = { 0x01 };
      static constexpr uint8_t last_flag_value = { 0x40 } ;
  
      // flags values (internal)
      enum ESelectedOutputIds {
        E_AUDIO_INPUT_L          = 0x01,
        E_AUDIO_INPUT_R          = 0x02,
        E_RADIO_TRANSMIT         = 0x04,
        E_DRIVER_HANDPHONE       = 0x08,
        E_DRIVER_SPEAKER         = 0x10,
        E_CABIN_INNER_SPEAKER    = 0x20,
        E_VEHICLE_OUTHER_SPEAKER = 0x40
      };
  
      SelectedOutputIds()
        : m_selected_output_ids(0)
      {  }
  
      constexpr SelectedOutputIds(SelectedOutputIds::ESelectedOutputIds e_selected_output_ids) noexcept
        : m_selected_output_ids(e_selected_output_ids)
      {  }
  
      SelectedOutputIds(const SelectedOutputIds& selected_output_ids) noexcept
        : m_selected_output_ids(selected_output_ids.m_selected_output_ids)
      {  }
      
      SelectedOutputIds& operator=(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids = selected_output_ids.m_selected_output_ids;
        return *this;
      }
    
      bool operator==(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return (m_selected_output_ids == selected_output_ids.m_selected_output_ids);
      }
      
      bool operator!=(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return (m_selected_output_ids != selected_output_ids.m_selected_output_ids);
      }
      
      // No ordering operators
    
      SelectedOutputIds operator!() const noexcept
      {
        return SelectedOutputIds(m_selected_output_ids ^ (2 * last_flag_value - 1));
      }
  
      SelectedOutputIds operator|=(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids |= selected_output_ids.m_selected_output_ids;
        return *this;
      }
  
      SelectedOutputIds operator|(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return SelectedOutputIds(m_selected_output_ids | selected_output_ids.m_selected_output_ids);
      }
  
      SelectedOutputIds operator&=(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids &= selected_output_ids.m_selected_output_ids;
        return *this;
      }
  
      SelectedOutputIds operator&(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return SelectedOutputIds(m_selected_output_ids & selected_output_ids.m_selected_output_ids);
      }
  
      bool isAnyOf(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return (selected_output_ids.m_selected_output_ids & m_selected_output_ids);
      }
  
      bool hasAllOf(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return (selected_output_ids.m_selected_output_ids & m_selected_output_ids) == selected_output_ids.m_selected_output_ids;
      }
  
      void remove(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids &= ~selected_output_ids.m_selected_output_ids;
      }
  
      std::string toString() const;
      static SelectedOutputIds fromString(std::string text);
      
      friend std::ostream& operator<<(std::ostream& output, const SelectedOutputIds& selected_output_ids);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const SelectedOutputIds& selected_output_ids)
      {
        output.storeInteger(selected_output_ids.m_selected_output_ids);
        return output;
      }
      
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, SelectedOutputIds& selected_output_ids)
      {
        input.readInteger(selected_output_ids.m_selected_output_ids);
        return input;
      }
  
    private:
      uint8_t m_selected_output_ids;
  
      static const char* m_selected_output_ids_bits_names[];
  
      SelectedOutputIds(uint8_t selected_output_ids)
        : m_selected_output_ids(selected_output_ids)
      {  }
  
      static ESelectedOutputIds convertTextToSingleFlag(const std::string& text);
  };
  
  constexpr SelectedOutputIds AUDIO_INPUT_L { SelectedOutputIds(SelectedOutputIds::E_AUDIO_INPUT_L) };
  constexpr SelectedOutputIds AUDIO_INPUT_R { SelectedOutputIds(SelectedOutputIds::E_AUDIO_INPUT_R) };
  constexpr SelectedOutputIds RADIO_TRANSMIT { SelectedOutputIds(SelectedOutputIds::E_RADIO_TRANSMIT) };
  constexpr SelectedOutputIds DRIVER_HANDPHONE { SelectedOutputIds(SelectedOutputIds::E_DRIVER_HANDPHONE) };
  constexpr SelectedOutputIds DRIVER_SPEAKER { SelectedOutputIds(SelectedOutputIds::E_DRIVER_SPEAKER) };
  constexpr SelectedOutputIds CABIN_INNER_SPEAKER { SelectedOutputIds(SelectedOutputIds::E_CABIN_INNER_SPEAKER) };
  constexpr SelectedOutputIds VEHICLE_OUTHER_SPEAKER { SelectedOutputIds(SelectedOutputIds::E_VEHICLE_OUTHER_SPEAKER) };

} // end Acoustic

// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/acoustic_selected_output_ids.h
// and it is generated by:      .../test.py[102]
// based on pattern file:       .../patterns/bitflags.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <string>
#include <iostream>

#include "serialization_binary_serialization.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Acoustic
{
  class SelectedOutputIds
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Acoustic::SelectedOutputIds" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { false };
      static constexpr bool size_in_bytes = { 1 };
      static constexpr uint8_t first_flag_value = { 0x01 };
      static constexpr uint8_t last_flag_value = { 0x40 } ;
  
      // flags values (internal)
      enum eSelectedOutputIds : uint8_t
      {
        E_AUDIO_INPUT_L          = 0x01,
        E_AUDIO_INPUT_R          = 0x02,
        E_RADIO_TRANSMIT         = 0x04,
        E_DRIVER_HANDPHONE       = 0x08,
        E_DRIVER_SPEAKER         = 0x10,
        E_CABIN_INNER_SPEAKER    = 0x20,
        E_VEHICLE_OUTHER_SPEAKER = 0x40
      };
  
      SelectedOutputIds() noexcept
      : m_selected_output_ids(0)
      {  }
      
      constexpr explicit SelectedOutputIds(eSelectedOutputIds selected_output_ids) noexcept
      : m_selected_output_ids(selected_output_ids)
      {  }
      
      SelectedOutputIds(const SelectedOutputIds& selected_output_ids) noexcept = default;
      SelectedOutputIds(SelectedOutputIds&& selected_output_ids) noexcept = default;
      SelectedOutputIds& operator=(const SelectedOutputIds& selected_output_ids) noexcept = default;
      SelectedOutputIds& operator=(SelectedOutputIds&& selected_output_ids) noexcept = default;
    
      uint8_t getSelectedOutputIdsAsInt() const noexcept { return m_selected_output_ids; }
  
      const SelectedOutputIds& getSelectedOutputIds() const noexcept { return *this; }
      
      void setSelectedOutputIds(const SelectedOutputIds& selected_output_ids) { *this = selected_output_ids; }
      void setSelectedOutputIds(eSelectedOutputIds selected_output_ids) { *this = SelectedOutputIds(selected_output_ids); }
      void setFrom(const SelectedOutputIds& selected_output_ids) { *this = selected_output_ids; }
      void setFrom(SelectedOutputIds&& selected_output_ids) { *this = selected_output_ids; }
  
      bool operator==(const SelectedOutputIds& selected_output_ids) const noexcept { return (m_selected_output_ids == selected_output_ids.m_selected_output_ids); }
      bool operator!=(const SelectedOutputIds& selected_output_ids) const noexcept { return (m_selected_output_ids != selected_output_ids.m_selected_output_ids); }
      // No ordering operators
    
      SelectedOutputIds operator!() const noexcept
      {
        return SelectedOutputIds(m_selected_output_ids ^ (2 * last_flag_value - 1));
      }
  
      SelectedOutputIds operator|=(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids |= selected_output_ids.m_selected_output_ids;
        return *this;
      }
  
      SelectedOutputIds operator|(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return SelectedOutputIds(m_selected_output_ids | selected_output_ids.m_selected_output_ids);
      }
  
      SelectedOutputIds operator&=(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids &= selected_output_ids.m_selected_output_ids;
        return *this;
      }
  
      SelectedOutputIds operator&(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return SelectedOutputIds(m_selected_output_ids & selected_output_ids.m_selected_output_ids);
      }
  
      bool isAnyOfSelectedOutputIds(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return (selected_output_ids.m_selected_output_ids & m_selected_output_ids);
      }
  
      bool hasAllOfSelectedOutputIds(const SelectedOutputIds& selected_output_ids) const noexcept
      {
        return (selected_output_ids.m_selected_output_ids & m_selected_output_ids) == selected_output_ids.m_selected_output_ids;
      }
  
      void removeSelectedOutputIds(const SelectedOutputIds& selected_output_ids) noexcept
      {
        m_selected_output_ids &= ~selected_output_ids.m_selected_output_ids;
      }
  
      std::string toString() const;
      static SelectedOutputIds fromString(const std::string& text);
      
      friend std::ostream& operator<<(std::ostream& output, const SelectedOutputIds& selected_output_ids);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const SelectedOutputIds& selected_output_ids)
      {
        output.storeValue(selected_output_ids.m_selected_output_ids);
        return output;
      }
      
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, SelectedOutputIds& selected_output_ids)
      {
        input.readValue(selected_output_ids.m_selected_output_ids);
        return input;
      }
  
    private:
      uint8_t m_selected_output_ids;
  
      static const char* m_selected_output_ids_bits_names[];
  
      SelectedOutputIds(uint8_t selected_output_ids)
        : m_selected_output_ids(selected_output_ids)
      {  }
  
      static eSelectedOutputIds convertTextToSingleFlag(const std::string& text);
      static eSelectedOutputIds convertTextToPossibleFlag(const std::string& text) noexcept;
      static std::string convertSingleFlagToString(eSelectedOutputIds bit) noexcept;
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
  
  constexpr SelectedOutputIds AUDIO_INPUT_L { SelectedOutputIds(SelectedOutputIds::E_AUDIO_INPUT_L) };
  constexpr SelectedOutputIds AUDIO_INPUT_R { SelectedOutputIds(SelectedOutputIds::E_AUDIO_INPUT_R) };
  constexpr SelectedOutputIds RADIO_TRANSMIT { SelectedOutputIds(SelectedOutputIds::E_RADIO_TRANSMIT) };
  constexpr SelectedOutputIds DRIVER_HANDPHONE { SelectedOutputIds(SelectedOutputIds::E_DRIVER_HANDPHONE) };
  constexpr SelectedOutputIds DRIVER_SPEAKER { SelectedOutputIds(SelectedOutputIds::E_DRIVER_SPEAKER) };
  constexpr SelectedOutputIds CABIN_INNER_SPEAKER { SelectedOutputIds(SelectedOutputIds::E_CABIN_INNER_SPEAKER) };
  constexpr SelectedOutputIds VEHICLE_OUTHER_SPEAKER { SelectedOutputIds(SelectedOutputIds::E_VEHICLE_OUTHER_SPEAKER) };
  
  // vvv--- YOU CAN PUT ADDITIONAL DEFINITIONS BELOW
  
  // ^^^--- END OF USER DEFINED DEFINITIONS

} // end Acoustic

// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/common_delay.h
// and it is generated by:      .../test.py[128]
// based on pattern file:       .../patterns/time.duration.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <chrono>
#include <string>
#include <iostream>

#include "serialization_binary_serialization.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Common
{
  class Delay
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Common::Delay" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      typedef std::chrono::system_clock ClockType;
      typedef std::chrono::system_clock::duration TimeDurationType;
  
      Delay() noexcept
      : m_delay(std::chrono::milliseconds(10))
      {  }
      
      constexpr explicit Delay(TimeDurationType delay) noexcept
      : m_delay(delay)
      {  }
      
      Delay(const Delay& delay) noexcept = default;
      Delay(Delay&& delay) noexcept = default;
      Delay& operator=(const Delay& delay) noexcept = default;
      Delay& operator=(Delay&& delay) noexcept = default;
  
      TimeDurationType getDelayAsTimeDuration() const noexcept { return m_delay; }
  
      const Delay& getDelay() const noexcept { return *this; }
      
      void setDelay(const Delay& delay) { *this = delay; }
      void setDelay(TimeDurationType delay) { *this = Delay(delay); }
      void setFrom(const Delay& delay) { *this = delay; }
      void setFrom(Delay&& delay) { *this = delay; }
  
      bool operator==(const Delay& delay) const noexcept { return (m_delay == delay.m_delay); }
      bool operator!=(const Delay& delay) const noexcept { return (m_delay != delay.m_delay); }
      bool operator<(const Delay& delay) const noexcept { return (m_delay < delay.m_delay); }
      bool operator<=(const Delay& delay) const noexcept { return (m_delay <= delay.m_delay); }
      bool operator>=(const Delay& delay) const noexcept { return (m_delay >= delay.m_delay); }
      bool operator>(const Delay& delay) const noexcept { return (m_delay > delay.m_delay); }
  
      std::string toString() const;
      static Delay fromString(const std::string& text);
      
      friend std::ostream& operator<<(std::ostream& output, const Delay& delay);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& serializer, const Delay& delay) 
      {
        uint64_t duration = std::chrono::duration_cast<std::chrono::microseconds>(delay.m_delay).count(); 
        serializer.storeValue(duration); 
        return serializer; 
      }
  
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& deserializer, Delay& delay)
      { 
        uint64_t duration; 
        deserializer.readValue(duration); 
        delay.m_delay = std::chrono::duration_cast<TimeDurationType>(std::chrono::microseconds(duration)); 
        return deserializer; 
      }
  
    private:
      TimeDurationType m_delay;
  
      // vvv--- YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  
      // ^^^--- YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  };
} // end Common

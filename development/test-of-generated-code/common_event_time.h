// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/common_event_time.h
// and it is generated by:      .../test.py[129]
// based on pattern file:       .../patterns/time.point.h.body.pattern
// wrapped by pattern:          .../patterns/source.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <chrono>
#include <string>
#include <iostream>

#include "serialization_binary_serialization.h"

// -vvv YOU CAN PUT ADDITIONAL INCLUDES BELOW

// -^^^ END OF USER DEFINED INCLUDES

namespace Common
{
  class EventTime
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Common::EventTime" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      typedef std::chrono::system_clock ClockType;
      typedef std::chrono::time_point<ClockType> TimePointType;
  
      EventTime() noexcept
        : m_event_time( ClockType::now() )
      {  }
  
      explicit EventTime(const TimePointType& event_time) noexcept 
        : m_event_time( event_time ) 
      {  }
  
      EventTime(TimePointType&& event_time) noexcept 
        : m_event_time( event_time )
      {  }
  
      EventTime(const EventTime& event_time) noexcept = default;
      EventTime(EventTime&& event_time) noexcept = default;
      EventTime& operator=(const EventTime& event_time) noexcept = default;
      EventTime& operator=(EventTime&& event_time) noexcept = default;
  
      void setEventTime(TimePointType event_time) noexcept { m_event_time = event_time; }
      void setEventTime(const EventTime& event_time) noexcept{ *this = event_time; }
      void setFrom(const EventTime& event_time) noexcept { *this = event_time; }
      void setFrom(EventTime&& event_time) noexcept { *this = event_time; }
      
      const EventTime& getEventTime() const noexcept { return *this; }
      TimePointType getEventTimeAsTimePoint() const noexcept { return m_event_time; }
  
      bool operator==(const EventTime& event_time) const noexcept { return (m_event_time == event_time.m_event_time); }
      bool operator!=(const EventTime& event_time) const noexcept { return (m_event_time != event_time.m_event_time);}
      bool operator<(const EventTime& event_time) const noexcept { return (m_event_time < event_time.m_event_time); }
      bool operator<=(const EventTime& event_time) const noexcept { return (m_event_time <= event_time.m_event_time); }
      bool operator>=(const EventTime& event_time) const noexcept { return (m_event_time >= event_time.m_event_time); }
      bool operator>(const EventTime& event_time) const noexcept { return (m_event_time > event_time.m_event_time); }
  
      std::string toString() const;
      static EventTime fromString(std::string text);
      
      friend std::ostream& operator<<(std::ostream& output, const EventTime& event_time);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& serializer, const EventTime& event_time) 
      {
        uint64_t time = std::chrono::duration_cast<std::chrono::microseconds>(event_time.m_event_time.time_since_epoch()).count(); 
        serializer.storeValue(time); 
        return serializer; 
      }
  
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& deserializer, EventTime& event_time)
      { 
        uint64_t time; 
        deserializer.readValue(time); 
        event_time.m_event_time = TimePointType(std::chrono::microseconds(time)); 
        return deserializer; 
      }
  
    private:
      TimePointType m_event_time;
  
      // -vvv YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  
      // -^^^ YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  };
} // end Common

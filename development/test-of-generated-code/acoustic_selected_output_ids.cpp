// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/acoustic_selected_output_ids.cpp
// and it is generated by:      .../test.py[102]
// based on pattern file:       .../patterns/bitflags.cpp.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#include <sstream>

#include "acoustic_selected_output_ids.h"
#include "common_conversion_error.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Acoustic
{
  std::string SelectedOutputIds::toString() const
  {
    std::ostringstream string_representation;
    string_representation << *this;
    return string_representation.str();
  }
  
  SelectedOutputIds SelectedOutputIds::fromString(const std::string& text)
  {
    SelectedOutputIds selected_output_ids;
    if (text == "" || text == "NONE")
    {
      return selected_output_ids;
    }
    else
    {
      std::string remaining_text = text;
      for (size_t separator_position = remaining_text.find_first_of("|"); 
           separator_position != std::string::npos; 
           separator_position = remaining_text.find_first_of("|"))
      {
        selected_output_ids |= SelectedOutputIds::convertTextToSingleFlag(remaining_text.substr(0, separator_position));
        remaining_text = remaining_text.substr(separator_position + 1);
      }
      selected_output_ids |= SelectedOutputIds::convertTextToSingleFlag(remaining_text);
      return selected_output_ids;
    }
  }
  
  std::ostream& operator<<(std::ostream& output, const SelectedOutputIds& selected_output_ids)
  {
    if (selected_output_ids.m_selected_output_ids)
    {
      const char* separator = "";
      uint8_t string_index = 0;
      for (uint8_t mask = SelectedOutputIds::first_flag_value; mask <= SelectedOutputIds::last_flag_value; mask *= 2, ++string_index)
      {
        if (mask & selected_output_ids.m_selected_output_ids)
        {
          output << separator << SelectedOutputIds::m_selected_output_ids_bits_names[string_index];
          separator = "|";
        }
      }
    }
    else
    {
      output << "NONE";
    }
    return output;
  }
  
  const char* SelectedOutputIds::m_selected_output_ids_bits_names[] = {
    "AUDIO_INPUT_L",
    "AUDIO_INPUT_R",
    "RADIO_TRANSMIT",
    "DRIVER_HANDPHONE",
    "DRIVER_SPEAKER",
    "CABIN_INNER_SPEAKER",
    "VEHICLE_OUTHER_SPEAKER"
  };
  
  SelectedOutputIds::eSelectedOutputIds SelectedOutputIds::convertTextToSingleFlag(const std::string& text)
  {
    eSelectedOutputIds possible_result = convertTextToPossibleFlag(text);
    if (convertSingleFlagToString(possible_result) == text)
    {
      return possible_result;
    }
    else
    {
      throw Common::ConversionError(text, "cannot be interpreted as Acoustic::SelectedOutputIds");
    }
  }
  
  SelectedOutputIds::eSelectedOutputIds SelectedOutputIds::convertTextToPossibleFlag(const std::string& text) noexcept
  {
    if (text.length() < 13)
    {
      return E_VEHICLE_OUTHER_SPEAKER;
    }
    switch (text[12])
    {
      case 'E':
        return E_VEHICLE_OUTHER_SPEAKER;
      case 'H':
        return E_DRIVER_HANDPHONE;
      case 'I':
        return E_RADIO_TRANSMIT;
      case 'L':
        return E_AUDIO_INPUT_L;
      case 'R':
        return E_AUDIO_INPUT_R;
      default:
      {
        return E_CABIN_INNER_SPEAKER;
      }
    }
  }
  
  std::string SelectedOutputIds::convertSingleFlagToString(SelectedOutputIds::eSelectedOutputIds bit) noexcept
  {
    unsigned bit_number = 0;
    uint8_t bit_value = static_cast<uint8_t>(bit);
    while (bit_value != 0x01)
    {
      bit_value >>= 1;
      ++bit_number;
    }
    return m_selected_output_ids_bits_names[bit_number];
  }
  
  // vvv--- YOU CAN PUT ADDITIONAL CODE BELOW
  
  // ^^^--- END OF USER DEFINED CODE

} // end Acoustic

// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/acoustic_selected_output_ids.cpp
// and it is generated by:      .../test.py[66]
// based on pattern file:       .../patterns/bitflags.cpp.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#include <sstream>

#include "acoustic_selected_output_ids.h"
#include "common_conversion_error.h" // TO BE CHANGED

namespace Acoustic
{
  std::string SelectedOutputIds::toString() const
  {
    std::ostringstream string_representation;
    string_representation << *this;
    return string_representation.str();
  }
  
  SelectedOutputIds SelectedOutputIds::fromString(std::string text)
  {
    SelectedOutputIds selected_output_ids;
    if (text == "" || text == "NONE")
    {
      return selected_output_ids;
    }
    else
    {
      for (size_t separator_position = text.find_first_of("|"); 
           separator_position != std::string::npos; 
           separator_position = text.find_first_of("|"))
      {
        selected_output_ids |= SelectedOutputIds::convertTextToSingleFlag(text.substr(0, separator_position));
        text = text.substr(separator_position + 1);
      }
      selected_output_ids |= SelectedOutputIds::convertTextToSingleFlag(text);
      return selected_output_ids;
    }
  }
  
  std::ostream& operator<<(std::ostream& output, const SelectedOutputIds& selected_output_ids)
  {
    if (selected_output_ids.m_selected_output_ids)
    {
      const char* separator = "";
      uint8_t string_index = 0;
      for (uint8_t mask = SelectedOutputIds::first_flag_value; mask <= SelectedOutputIds::last_flag_value; mask *= 2, ++string_index)
      {
        if (mask & selected_output_ids.m_selected_output_ids)
        {
          output << separator << SelectedOutputIds::m_selected_output_ids_bits_names[string_index];
          separator = "|";
        }
      }
    }
    else
    {
      output << "NONE";
    }
    return output;
  }
  
  const char* SelectedOutputIds::m_selected_output_ids_bits_names[] = {
    "AUDIO_INPUT_L",
    "AUDIO_INPUT_R",
    "RADIO_TRANSMIT",
    "DRIVER_HANDPHONE",
    "DRIVER_SPEAKER",
    "CABIN_INNER_SPEAKER",
    "VEHICLE_OUTHER_SPEAKER"
  };
  
  SelectedOutputIds::ESelectedOutputIds SelectedOutputIds::convertTextToSingleFlag(const std::string& text)
  {
    if (text == "AUDIO_INPUT_L")
    {
      return E_AUDIO_INPUT_L;
    }
    if (text == "AUDIO_INPUT_R")
    {
      return E_AUDIO_INPUT_R;
    }
    if (text == "RADIO_TRANSMIT")
    {
      return E_RADIO_TRANSMIT;
    }
    if (text == "DRIVER_HANDPHONE")
    {
      return E_DRIVER_HANDPHONE;
    }
    if (text == "DRIVER_SPEAKER")
    {
      return E_DRIVER_SPEAKER;
    }
    if (text == "CABIN_INNER_SPEAKER")
    {
      return E_CABIN_INNER_SPEAKER;
    }
    if (text == "VEHICLE_OUTHER_SPEAKER")
    {
      return E_VEHICLE_OUTHER_SPEAKER;
    }
    throw Common::ConversionError(text, "cannot be interpreted as ::SelectedOutputIds::ESelectedOutputIds");
  }
} // end Acoustic

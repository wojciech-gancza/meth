// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_nodes.h
// and it is generated by:      .../test.py[149]
// based on pattern file:       .../patterns/collection.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <vector>
#include <string>
#include <iostream>

#include "common_size_error.h"
#include "serialization_binary_serialization.h"

namespace Configuration
{
  class Node;
}

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  class Nodes
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Configuration::Nodes" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      static constexpr uint16_t max_count = { 64000 };
  
      Nodes() = default;
      Nodes(const Nodes& nodes) = default;
      Nodes(Nodes&& nodes) = default;
      Nodes& operator=(const Nodes& nodes) = default;
      Nodes& operator=(Nodes&& nodes) = default;
  
      void insertNode(const Node& node) { m_nodes.push_back(node); checkSize(); }
      void insertNode(Node&& node) { m_nodes.push_back(node); checkSize(); }
  
      uint16_t getNodesCount() const { return static_cast<uint16_t>(m_nodes.size()); }
  
      bool operator==(const Nodes& nodes) const noexcept;
      bool operator!=(const Nodes& nodes) const noexcept;
      bool operator<(const Nodes& nodes) const noexcept;
      bool operator<=(const Nodes& nodes) const noexcept;
      bool operator>=(const Nodes& nodes) const noexcept;
      bool operator>(const Nodes& nodes) const noexcept;
  
      class Iterator : public std::vector<Configuration::Node>::iterator
      { 
        public: 
          Iterator() {} 
          Iterator(const std::vector<Configuration::Node>::iterator& iterator) : std::vector<Configuration::Node>::iterator(iterator) { }
          Iterator(const Iterator& iterator) = default;
          Iterator(Iterator&& iterator) = default;
          Iterator& operator=(const Iterator& iterator) = default;
          Iterator& operator=(Iterator&& iterator) = default;
      };
  
      class ConstIterator : public std::vector<Configuration::Node>::const_iterator
      { 
        public: 
          ConstIterator() {} 
          ConstIterator(const std::vector<Configuration::Node>::const_iterator& iterator) : std::vector<Configuration::Node>::const_iterator(iterator) { }
          ConstIterator(const ConstIterator& iterator) = default;
          ConstIterator(ConstIterator&& iterator) = default;
          ConstIterator& operator=(const ConstIterator& iterator) = default;
          ConstIterator& operator=(ConstIterator&& iterator) = default;
      };
  
      class ReverseIterator : public std::vector<Configuration::Node>::reverse_iterator
      { 
        public: 
          ReverseIterator() {} 
          ReverseIterator(const std::vector<Configuration::Node>::reverse_iterator& iterator) : std::vector<Configuration::Node>::reverse_iterator(iterator) { }
          ReverseIterator(const ReverseIterator& iterator) = default;
          ReverseIterator(ReverseIterator&& iterator) = default;
          ReverseIterator& operator=(const ReverseIterator& iterator) = default;
          ReverseIterator& operator=(ReverseIterator&& iterator) = default;
      };
  
      class ConstReverseIterator : public std::vector<Configuration::Node>::const_reverse_iterator
      { 
        public: 
          ConstReverseIterator() {} 
          ConstReverseIterator(const std::vector<Configuration::Node>::const_reverse_iterator& iterator) : std::vector<Configuration::Node>::const_reverse_iterator(iterator) { }
          ConstReverseIterator(const ConstReverseIterator& iterator) = default;
          ConstReverseIterator(ConstReverseIterator&& iterator) = default;
          ConstReverseIterator& operator=(const ConstReverseIterator& iterator) = default;
          ConstReverseIterator& operator=(ConstReverseIterator&& iterator) = default;
      };
  
      Iterator getNodesBegin() { return Iterator(m_nodes.begin()); }
      Iterator getNodesEnd() { return Iterator(m_nodes.end()); }
  
      ConstIterator getNodesBegin() const { return ConstIterator(m_nodes.begin()); }
      ConstIterator getNodesEnd() const { return ConstIterator(m_nodes.end()); }
  
      ConstIterator getNodesConstBegin() const { return ConstIterator(m_nodes.begin()); }
      ConstIterator getNodesConstEnd() const { return ConstIterator(m_nodes.end()); }
  
      ReverseIterator getNodesReverseBegin() { return ReverseIterator(m_nodes.rbegin()); }
      ReverseIterator getNodesReverseEnd() { return ReverseIterator(m_nodes.rend()); }
  
      ConstReverseIterator getNodesReverseBegin() const { return ConstReverseIterator(m_nodes.rbegin()); }
      ConstReverseIterator getNodesReverseEnd() const { return ConstReverseIterator(m_nodes.rend()); }
  
      ConstReverseIterator getNodesReverseConstBegin() const { return ConstReverseIterator(m_nodes.rbegin()); }
      ConstReverseIterator getNodesReverseConstEnd() const { return ConstReverseIterator(m_nodes.rend()); }
  
      // ...
  
      std::string toString() const;
  
      friend std::ostream& operator<<(std::ostream& output, const Nodes& nodes);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const Nodes& nodes);
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, Nodes& nodes);
  
    private:
      std::vector<Configuration::Node> m_nodes;
  
      void checkSize()
      {
        // vvv--- YOU CAN PUT VALUE CHECK HANDLING HERE
        if (getNodesCount() > max_count)
        {
          throw Common::SizeError(getNodesCount(), "too long string to initiate Nodes");
        }
        // ^^^--- END OF VALUE CHECK HANDLING HERE
      }
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Configuration

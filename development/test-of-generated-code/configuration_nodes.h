// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_nodes.h
// and it is generated by:      .../test.py[153]
// based on pattern file:       .../patterns/collection.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <vector>
#include <string>
#include <iostream>

#include "common_size_error.h"
#include "serialization_binary_serialization.h"

namespace Configuration
{
  class Node;
}

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  class Nodes
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Configuration::Nodes" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      static constexpr uint16_t max_count = { 64000 };
  
      Nodes() = default;
      Nodes(const Nodes& nodes) = default;
      Nodes(Nodes&& nodes) = default;
      Nodes& operator=(const Nodes& nodes) = default;
      Nodes& operator=(Nodes&& nodes) = default;
  
      void insertNode(const Node& node) { m_nodes.push_back(node); checkSize(); }
      void insertNode(Node&& node) { m_nodes.push_back(node); checkSize(); }
  
      uint16_t getNodesCount() const { return static_cast<uint16_t>(m_nodes.size()); }
  
      bool operator==(const Nodes& nodes) const noexcept;
      bool operator!=(const Nodes& nodes) const noexcept;
      bool operator<(const Nodes& nodes) const noexcept;
      bool operator<=(const Nodes& nodes) const noexcept;
      bool operator>=(const Nodes& nodes) const noexcept;
      bool operator>(const Nodes& nodes) const noexcept;
  
      class Iterator : public std::vector<Configuration::Node>::iterator
      { 
        public: 
          Iterator() {} 
          Iterator(const std::vector<Configuration::Node>::iterator& iterator) noexcept : std::vector<Configuration::Node>::iterator(iterator) { }
          Iterator(const Iterator& iterator) noexcept = default;
          Iterator(Iterator&& iterator) noexcept = default;
          Iterator& operator=(const Iterator& iterator) noexcept = default;
          Iterator& operator=(Iterator&& iterator) noexcept = default;
      };
  
      class ConstIterator : public std::vector<Configuration::Node>::const_iterator
      { 
        public: 
          ConstIterator() {} 
          ConstIterator(const std::vector<Configuration::Node>::const_iterator& iterator) noexcept : std::vector<Configuration::Node>::const_iterator(iterator) { }
          ConstIterator(const ConstIterator& iterator) noexcept = default;
          ConstIterator(ConstIterator&& iterator) noexcept = default;
          ConstIterator& operator=(const ConstIterator& iterator) noexcept = default;
          ConstIterator& operator=(ConstIterator&& iterator) noexcept = default;
      };
  
      class ReverseIterator : public std::vector<Configuration::Node>::reverse_iterator
      { 
        public: 
          ReverseIterator() {} 
          ReverseIterator(const std::vector<Configuration::Node>::reverse_iterator& iterator) noexcept : std::vector<Configuration::Node>::reverse_iterator(iterator) { }
          ReverseIterator(const ReverseIterator& iterator) noexcept = default;
          ReverseIterator(ReverseIterator&& iterator) noexcept = default;
          ReverseIterator& operator=(const ReverseIterator& iterator) noexcept = default;
          ReverseIterator& operator=(ReverseIterator&& iterator) noexcept = default;
      };
  
      class ConstReverseIterator : public std::vector<Configuration::Node>::const_reverse_iterator
      { 
        public: 
          ConstReverseIterator() {} 
          ConstReverseIterator(const std::vector<Configuration::Node>::const_reverse_iterator& iterator) noexcept : std::vector<Configuration::Node>::const_reverse_iterator(iterator) { }
          ConstReverseIterator(const ConstReverseIterator& iterator) noexcept = default;
          ConstReverseIterator(ConstReverseIterator&& iterator) noexcept = default;
          ConstReverseIterator& operator=(const ConstReverseIterator& iterator) noexcept = default;
          ConstReverseIterator& operator=(ConstReverseIterator&& iterator) noexcept = default;
      };
  
      Iterator getNodesBegin() { return Iterator(m_nodes.begin()); }
      Iterator getNodesEnd() { return Iterator(m_nodes.end()); }
  
      ConstIterator getNodesBegin() const { return ConstIterator(m_nodes.begin()); }
      ConstIterator getNodesEnd() const { return ConstIterator(m_nodes.end()); }
  
      ConstIterator getNodesConstBegin() const { return ConstIterator(m_nodes.begin()); }
      ConstIterator getNodesConstEnd() const { return ConstIterator(m_nodes.end()); }
  
      ReverseIterator getNodesReverseBegin() { return ReverseIterator(m_nodes.rbegin()); }
      ReverseIterator getNodesReverseEnd() { return ReverseIterator(m_nodes.rend()); }
  
      ConstReverseIterator getNodesReverseBegin() const { return ConstReverseIterator(m_nodes.rbegin()); }
      ConstReverseIterator getNodesReverseEnd() const { return ConstReverseIterator(m_nodes.rend()); }
  
      ConstReverseIterator getNodesReverseConstBegin() const { return ConstReverseIterator(m_nodes.rbegin()); }
      ConstReverseIterator getNodesReverseConstEnd() const { return ConstReverseIterator(m_nodes.rend()); }
  
      class SearchResult
      {
        public:
          SearchResult() = default;
          SearchResult(const SearchResult& nodes) = default;
          SearchResult(SearchResult&& nodes) = default;
          SearchResult& operator=(const SearchResult& nodes) = default;
          SearchResult& operator=(SearchResult&& nodes) = default;
      
          void insertIterator(const Nodes::Iterator& item) { m_found_nodes.push_back(item); };
      
          class Iterator : public std::vector<Nodes::Iterator>::iterator
          { 
            public: 
              Iterator() {} 
              Iterator(const std::vector<Nodes::Iterator>::iterator& iterator) noexcept : std::vector<Nodes::Iterator>::iterator(iterator) { }
              Iterator(const Iterator& iterator) noexcept = default;
              Iterator(Iterator&& iterator) noexcept = default;
              Iterator& operator=(const Iterator& iterator) noexcept = default;
              Iterator& operator=(Iterator&& iterator) noexcept = default;
          
              Configuration::Node& operator*() const noexcept { return *(std::vector<Nodes::Iterator>::iterator::operator*()); }
              Configuration::Node* operator->() const noexcept { return &(*(std::vector<Nodes::Iterator>::iterator::operator*())); }
          
              Nodes::Iterator& getIteratorToNodes() const { return std::vector<Nodes::Iterator>::iterator::operator*(); }
          };
      
          class ReverseIterator : public std::vector<Nodes::Iterator>::reverse_iterator
          { 
            public: 
              ReverseIterator() {} 
              ReverseIterator(const std::vector<Nodes::Iterator>::reverse_iterator& iterator) noexcept : std::vector<Nodes::Iterator>::reverse_iterator(iterator) { }
              ReverseIterator(const ReverseIterator& iterator) noexcept = default;
              ReverseIterator(ReverseIterator&& iterator) noexcept = default;
              ReverseIterator& operator=(const ReverseIterator& iterator) noexcept = default;
              ReverseIterator& operator=(ReverseIterator&& iterator) noexcept = default;
          
              Configuration::Node& operator*() const noexcept { return *(std::vector<Nodes::Iterator>::reverse_iterator::operator*()); }
              Configuration::Node* operator->() const noexcept { return &(*(std::vector<Nodes::Iterator>::reverse_iterator::operator*())); }
          
              Nodes::Iterator& getIteratorToNodes() const { return std::vector<Nodes::Iterator>::reverse_iterator::operator*(); }
          };
      
          Iterator getNodesBegin() const { return Iterator(const_cast<std::vector<Nodes::Iterator>&>(m_found_nodes).begin()); }
          Iterator getNodesEnd() const { return Iterator(const_cast<std::vector<Nodes::Iterator>&>(m_found_nodes).end()); } 
      
          ReverseIterator getNodesReverseBegin() const { return ReverseIterator(const_cast<std::vector<Nodes::Iterator>&>(m_found_nodes).rbegin()); }
          ReverseIterator getNodesReverseEnd() const { return ReverseIterator(const_cast<std::vector<Nodes::Iterator>&>(m_found_nodes).rend()); }
      
          template <class KEY>
          SearchResult searchNodes(const KEY& key)
          {
            SearchResult search_result;
            for (Iterator item = getNodesBegin(); item != getNodesEnd(); ++item)
            {
              if (*item == key)
              {
                search_result.insertIterator(item.getIteratorToNodes());
              }
            }
            return search_result;
          }
      
          void removeNodesIterator(const Iterator& iterator) { m_found_nodes.erase(iterator); }
      
          SearchResult& operator+=(const SearchResult& result_to_append)
          {
            for (Iterator item = result_to_append.getNodesBegin(); item != result_to_append.getNodesEnd(); ++item)
            {
              m_found_nodes.push_back(item.getIteratorToNodes());
            }
            return *this;
          }
      
          SearchResult& operator-=(const SearchResult& result_to_remove)
          {
            for (Iterator item = result_to_remove.getNodesBegin(); item != result_to_remove.getNodesEnd(); ++item)
            {
              std::vector<Nodes::Iterator>::const_iterator nodes_pointer = std::find(m_found_nodes.begin(), m_found_nodes.end(), item.getIteratorToNodes());
              if (nodes_pointer != m_found_nodes.end())
              {
                m_found_nodes.erase( nodes_pointer );
              }
            }
            return *this;
          }
      
          std::string toString() const;
          friend std::ostream& operator<<(std::ostream& output, const Nodes::SearchResult& nodes);
      
        private:
          std::vector<Nodes::Iterator> m_found_nodes;
      };
      
      template <class KEY>
      SearchResult searchNodes(const KEY& key)
      {
        SearchResult search_result;
        for (Iterator item = getNodesBegin(); item != getNodesEnd(); ++item)
        {
          if (*item == key)
          {
            search_result.insertIterator(item);
          }
        }
        return search_result;
      }
  
      class ConstSearchResult
      {
        public:
          ConstSearchResult() = default;
          ConstSearchResult(const ConstSearchResult& nodes) = default;
          ConstSearchResult(ConstSearchResult&& nodes) = default;
          ConstSearchResult& operator=(const ConstSearchResult& nodes) = default;
          ConstSearchResult& operator=(ConstSearchResult&& nodes) = default;
      
          void insertIterator(const Nodes::ConstIterator& item) { m_found_nodes.push_back(item); };
      
          class ConstIterator : public std::vector<Nodes::ConstIterator>::iterator
          { 
            public: 
              ConstIterator() {} 
              ConstIterator(const std::vector<Nodes::ConstIterator>::iterator& iterator) noexcept : std::vector<Nodes::ConstIterator>::iterator(iterator) { }
              ConstIterator(const ConstIterator& iterator) noexcept = default;
              ConstIterator(ConstIterator&& iterator) noexcept = default;
              ConstIterator& operator=(const ConstIterator& iterator) noexcept = default;
              ConstIterator& operator=(ConstIterator&& iterator) noexcept = default;
          
              const Configuration::Node& operator*() const noexcept { return *(std::vector<Nodes::ConstIterator>::iterator::operator*()); }
              const Configuration::Node* operator->() const noexcept { return &(*(std::vector<Nodes::ConstIterator>::iterator::operator*())); }
          
              Nodes::ConstIterator& getIteratorToNodes() const { return std::vector<Nodes::ConstIterator>::iterator::operator*(); }
          };
      
          class ConstReverseIterator : public std::vector<Nodes::ConstIterator>::reverse_iterator
          { 
            public: 
              ConstReverseIterator() {} 
              ConstReverseIterator(const std::vector<Nodes::ConstIterator>::reverse_iterator& iterator) noexcept : std::vector<Nodes::ConstIterator>::reverse_iterator(iterator) { }
              ConstReverseIterator(const ConstReverseIterator& iterator) noexcept = default;
              ConstReverseIterator(ConstReverseIterator&& iterator) noexcept = default;
              ConstReverseIterator& operator=(const ConstReverseIterator& iterator) noexcept = default;
              ConstReverseIterator& operator=(ConstReverseIterator&& iterator) noexcept = default;
          
              const Configuration::Node& operator*() const noexcept { return *(std::vector<Nodes::ConstIterator>::reverse_iterator::operator*()); }
              const Configuration::Node* operator->() const noexcept { return &(*(std::vector<Nodes::ConstIterator>::reverse_iterator::operator*())); }
          
              Nodes::ConstIterator& getIteratorToNodes() const { return std::vector<Nodes::ConstIterator>::reverse_iterator::operator*(); }
          };
      
          ConstIterator getNodesBegin() const { return ConstIterator(const_cast<std::vector<Nodes::ConstIterator>&>(m_found_nodes).begin()); }
          ConstIterator getNodesEnd() const { return ConstIterator(const_cast<std::vector<Nodes::ConstIterator>&>(m_found_nodes).end()); } 
      
          ConstReverseIterator getNodesReverseBegin() const { return ConstReverseIterator(const_cast<std::vector<Nodes::ConstIterator>&>(m_found_nodes).rbegin()); }
          ConstReverseIterator getNodesReverseEnd() const { return ConstReverseIterator(const_cast<std::vector<Nodes::ConstIterator>&>(m_found_nodes).rend()); }
      
          template <class KEY>
          ConstSearchResult searchNodes(const KEY& key)
          {
            ConstSearchResult search_result;
            for (ConstIterator item = getNodesBegin(); item != getNodesEnd(); ++item)
            {
              if (*item == key)
              {
                search_result.insertIterator(item.getIteratorToNodes());
              }
            }
            return search_result;
          }
      
          void removeNodesConstIterator(const ConstIterator& iterator) { m_found_nodes.erase(iterator); }
      
          ConstSearchResult& operator+=(const ConstSearchResult& result_to_append)
          {
            for (ConstIterator item = result_to_append.getNodesBegin(); item != result_to_append.getNodesEnd(); ++item)
            {
              m_found_nodes.push_back(item.getIteratorToNodes());
            }
            return *this;
          }
      
          ConstSearchResult& operator-=(const ConstSearchResult& result_to_remove)
          {
            for (ConstIterator item = result_to_remove.getNodesBegin(); item != result_to_remove.getNodesEnd(); ++item)
            {
              std::vector<Nodes::ConstIterator>::const_iterator nodes_pointer = std::find(m_found_nodes.begin(), m_found_nodes.end(), item.getIteratorToNodes());
              if (nodes_pointer != m_found_nodes.end())
              {
                m_found_nodes.erase( nodes_pointer );
              }
            }
            return *this;
          }
      
          std::string toString() const;
          friend std::ostream& operator<<(std::ostream& output, const Nodes::ConstSearchResult& nodes);
      
        private:
          std::vector<Nodes::ConstIterator> m_found_nodes;
      };
      
      template <class KEY>
      ConstSearchResult searchNodes(const KEY& key) const
      {
        ConstSearchResult search_result;
        for (ConstIterator item = getNodesBegin(); item != getNodesEnd(); ++item)
        {
          if (*item == key)
          {
            search_result.insertIterator(item);
          }
        }
        return search_result;
      }
  
      void removeNode(const Iterator& node);
      void removeNodes(const SearchResult& items_to_delete);
      template <class KEY> void removeNodes(const KEY& key) { removeNodes(searchNodes(key)); }
  
      Nodes& operator+=(const Nodes& nodes);
  
      std::string toString() const;
  
      friend std::ostream& operator<<(std::ostream& output, const Nodes& nodes);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const Nodes& nodes);
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, Nodes& nodes);
  
    private:
      std::vector<Configuration::Node> m_nodes;
  
      void checkSize()
      {
        // vvv--- YOU CAN PUT VALUE CHECK HANDLING HERE
        if (getNodesCount() > max_count)
        {
          throw Common::SizeError(getNodesCount(), "too long string to initiate Nodes");
        }
        // ^^^--- END OF VALUE CHECK HANDLING HERE
      }
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Configuration

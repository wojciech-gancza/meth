// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_nodes.h
// and it is generated by:      .../test.py[152]
// based on pattern file:       .../patterns/collection.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <vector>
#include <string>
#include <iostream>

#include "common_size_error.h"
#include "serialization_binary_serialization.h"

namespace Configuration
{
  class Node;
}

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  class Nodes
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Configuration::Nodes" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      static constexpr uint16_t max_count = { 64000 };
  
      Nodes() = default;
      Nodes(const Nodes& nodes) = default;
      Nodes(Nodes&& nodes) = default;
      Nodes& operator=(const Nodes& nodes) = default;
      Nodes& operator=(Nodes&& nodes) = default;
  
      void insertNode(const Node& node) { m_nodes.push_back(node); checkSize(); }
      void insertNode(Node&& node) { m_nodes.push_back(node); checkSize(); }
  
      uint16_t getNodesCount() const { return static_cast<uint16_t>(m_nodes.size()); }
  
      bool operator==(const Nodes& nodes) const noexcept;
      bool operator!=(const Nodes& nodes) const noexcept;
      bool operator<(const Nodes& nodes) const noexcept;
      bool operator<=(const Nodes& nodes) const noexcept;
      bool operator>=(const Nodes& nodes) const noexcept;
      bool operator>(const Nodes& nodes) const noexcept;
  
      class Iterator : public std::vector<Configuration::Node>::iterator
      { 
        public: 
          Iterator() {} 
          Iterator(const std::vector<Configuration::Node>::iterator& iterator) noexcept : std::vector<Configuration::Node>::iterator(iterator) { }
          Iterator(const Iterator& iterator) noexcept = default;
          Iterator(Iterator&& iterator) noexcept = default;
          Iterator& operator=(const Iterator& iterator) noexcept = default;
          Iterator& operator=(Iterator&& iterator) noexcept = default;
      };
  
      class ConstIterator : public std::vector<Configuration::Node>::const_iterator
      { 
        public: 
          ConstIterator() {} 
          ConstIterator(const std::vector<Configuration::Node>::const_iterator& iterator) noexcept : std::vector<Configuration::Node>::const_iterator(iterator) { }
          ConstIterator(const ConstIterator& iterator) noexcept = default;
          ConstIterator(ConstIterator&& iterator) noexcept = default;
          ConstIterator& operator=(const ConstIterator& iterator) noexcept = default;
          ConstIterator& operator=(ConstIterator&& iterator) noexcept = default;
      };
  
      class ReverseIterator : public std::vector<Configuration::Node>::reverse_iterator
      { 
        public: 
          ReverseIterator() {} 
          ReverseIterator(const std::vector<Configuration::Node>::reverse_iterator& iterator) noexcept : std::vector<Configuration::Node>::reverse_iterator(iterator) { }
          ReverseIterator(const ReverseIterator& iterator) noexcept = default;
          ReverseIterator(ReverseIterator&& iterator) noexcept = default;
          ReverseIterator& operator=(const ReverseIterator& iterator) noexcept = default;
          ReverseIterator& operator=(ReverseIterator&& iterator) noexcept = default;
      };
  
      class ConstReverseIterator : public std::vector<Configuration::Node>::const_reverse_iterator
      { 
        public: 
          ConstReverseIterator() {} 
          ConstReverseIterator(const std::vector<Configuration::Node>::const_reverse_iterator& iterator) noexcept : std::vector<Configuration::Node>::const_reverse_iterator(iterator) { }
          ConstReverseIterator(const ConstReverseIterator& iterator) noexcept = default;
          ConstReverseIterator(ConstReverseIterator&& iterator) noexcept = default;
          ConstReverseIterator& operator=(const ConstReverseIterator& iterator) noexcept = default;
          ConstReverseIterator& operator=(ConstReverseIterator&& iterator) noexcept = default;
      };
  
      Iterator getNodesBegin() { return Iterator(m_nodes.begin()); }
      Iterator getNodesEnd() { return Iterator(m_nodes.end()); }
  
      ConstIterator getNodesBegin() const { return ConstIterator(m_nodes.begin()); }
      ConstIterator getNodesEnd() const { return ConstIterator(m_nodes.end()); }
  
      ConstIterator getNodesConstBegin() const { return ConstIterator(m_nodes.begin()); }
      ConstIterator getNodesConstEnd() const { return ConstIterator(m_nodes.end()); }
  
      ReverseIterator getNodesReverseBegin() { return ReverseIterator(m_nodes.rbegin()); }
      ReverseIterator getNodesReverseEnd() { return ReverseIterator(m_nodes.rend()); }
  
      ConstReverseIterator getNodesReverseBegin() const { return ConstReverseIterator(m_nodes.rbegin()); }
      ConstReverseIterator getNodesReverseEnd() const { return ConstReverseIterator(m_nodes.rend()); }
  
      ConstReverseIterator getNodesReverseConstBegin() const { return ConstReverseIterator(m_nodes.rbegin()); }
      ConstReverseIterator getNodesReverseConstEnd() const { return ConstReverseIterator(m_nodes.rend()); }
  
      class SearchResult
      {
        public:
          SearchResult() = default;
          SearchResult(const SearchResult& nodes) = default;
          SearchResult(SearchResult&& nodes) = default;
          SearchResult& operator=(const SearchResult& nodes) = default;
          SearchResult& operator=(SearchResult&& nodes) = default;
  
          void insertIterator(const Nodes::Iterator& item) { m_found_nodes.push_back(item); };
  
          class Iterator : public std::vector<Nodes::Iterator>::iterator
          { 
            public: 
              Iterator() {} 
              Iterator(const std::vector<Nodes::Iterator>::iterator& iterator) noexcept : std::vector<Nodes::Iterator>::iterator(iterator) { }
              Iterator(const Iterator& iterator) noexcept = default;
              Iterator(Iterator&& iterator) noexcept = default;
              Iterator& operator=(const Iterator& iterator) noexcept = default;
              Iterator& operator=(Iterator&& iterator) noexcept = default;
          
              Configuration::Node& operator*() const noexcept { return *(std::vector<Nodes::Iterator>::iterator::operator*()); }
              Configuration::Node* operator->() const noexcept { return &(*(std::vector<Nodes::Iterator>::iterator::operator*())); }
          };
  
          class ReverseIterator : public std::vector<Nodes::Iterator>::reverse_iterator
          { 
            public: 
              ReverseIterator() {} 
              ReverseIterator(const std::vector<Nodes::Iterator>::reverse_iterator& iterator) noexcept : std::vector<Nodes::Iterator>::reverse_iterator(iterator) { }
              ReverseIterator(const ReverseIterator& iterator) noexcept = default;
              ReverseIterator(ReverseIterator&& iterator) noexcept = default;
              ReverseIterator& operator=(const ReverseIterator& iterator) noexcept = default;
              ReverseIterator& operator=(ReverseIterator&& iterator) noexcept = default;
          
              Configuration::Node& operator*() const noexcept { return *(std::vector<Nodes::Iterator>::reverse_iterator::operator*()); }
              Configuration::Node* operator->() const noexcept { return &(*(std::vector<Nodes::Iterator>::reverse_iterator::operator*())); }
          };
  
          Iterator getNodesBegin() { return Iterator(m_found_nodes.begin()); }
          Iterator getNodesEnd() { return Iterator(m_found_nodes.end()); }
  
          ReverseIterator getNodesReverseBegin() { return ReverseIterator(m_found_nodes.rbegin()); }
          ReverseIterator getNodesReverseEnd() { return ReverseIterator(m_found_nodes.rend()); }
  
          template <class KEY>
          SearchResult searchNodes(const KEY& key)
          {
            SearchResult search_result;
            for (Iterator item = getNodesBegin(); item != getNodesEnd(); ++item)
            {
              if (*item == key)
              {
                search_result.insertIterator(item);
              }
            }
            return search_result;
          }
  
          std::string toString() const;
          friend std::ostream& operator<<(std::ostream& output, const Nodes::SearchResult& nodes);
  
        private:
          std::vector<Nodes::Iterator> m_found_nodes;
      };
  
      template <class KEY>
      SearchResult searchNodes(const KEY& key)
      {
        SearchResult search_result;
        for (Iterator item = getNodesBegin(); item != getNodesEnd(); ++item)
        {
          if (*item == key)
          {
            search_result.insertIterator(item);
          }
        }
        return search_result;
      }
  
      void removeNode(const Iterator& node);
  
      // ... remove many (by key)
  
      // ...
  
      std::string toString() const;
  
      friend std::ostream& operator<<(std::ostream& output, const Nodes& nodes);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const Nodes& nodes);
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, Nodes& nodes);
  
    private:
      std::vector<Configuration::Node> m_nodes;
  
      void checkSize()
      {
        // vvv--- YOU CAN PUT VALUE CHECK HANDLING HERE
        if (getNodesCount() > max_count)
        {
          throw Common::SizeError(getNodesCount(), "too long string to initiate Nodes");
        }
        // ^^^--- END OF VALUE CHECK HANDLING HERE
      }
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Configuration

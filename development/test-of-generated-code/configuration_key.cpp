// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_key.cpp
// and it is generated by:      .../generator.py[130]
// based on pattern file:       .../patterns/string.cpp.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#include <sstream>
#include "configuration_key.h"
#include "common_conversion_error.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  std::string Key::toString() const
  {
    std::ostringstream buffer; 
    buffer << "\"";
    for (std::string::const_iterator character_ptr = m_key.begin(); character_ptr != m_key.end(); ++character_ptr)
    {
      switch(*character_ptr)
      {
        case '\'':
        case '\"':
        case '\\':
          buffer << '\\';
        default:
          buffer << *character_ptr;
      }
    }
    buffer << "\"";
    return buffer.str();
  }
  
  Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& serializer, const Key& key)
  {
    uint8_t count_of_bytes = key.getKeyLength();
    serializer.storeValue(count_of_bytes);
    for (std::string::const_iterator character_ptr = key.m_key.begin(); character_ptr != key.m_key.end(); ++character_ptr)
    {
      serializer.storeByte(*character_ptr);
    }
    return serializer;
  }
  
  Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& deserializer, Key& key)
  {
    uint8_t count_of_bytes;
    deserializer.readValue(count_of_bytes);
    std::string result(count_of_bytes, ' ');
    for (uint8_t position = 0; position < count_of_bytes; ++position)
    {
      deserializer.readByte(reinterpret_cast<uint8_t&>(result[position]));
    }
    key.setKey(result);
    return deserializer;
  }
   
  // vvv--- YOU CAN PUT ADDITIONAL DEFINITIONS BELOW
  
  // ^^^--- END OF USER DEFINED DEFINITIONS

} // end Configuration

// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_value.h
// and it is generated by:      .../generator.py[108]
// based on pattern file:       .../patterns/string.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <string>
#include <iostream>
#include "common_strcmp_compare.h"
#include "common_conversion_error.h"
#include "serialization_binary_serialization.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  class Value
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Configuration::Value" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { false };
      static constexpr uint16_t max_length = { 64000 };
  
      explicit Value(const char* value)
      : m_value(value)
      {  }
  
      explicit Value(std::string&& value)
      : m_value(value)
      {  }
  
      Value() noexcept
      : m_value("")
      {  }
      
      constexpr explicit Value(const std::string& value) noexcept
      : m_value(value)
      {  }
      
      Value(const Value& value) noexcept = default;
      Value(Value&& value) noexcept = default;
      Value& operator=(const Value& value) noexcept = default;
      Value& operator=(Value&& value) noexcept = default;
  
      std::string getValueAsString() const noexcept { return m_value; }
  
      const Value& getValue() const noexcept { return *this; }
      
      void setValue(const Value& value) { *this = value; }
      void setValue(const std::string& value) { *this = Value(value); }
      void setFrom(const Value& value) { *this = value; }
      void setFrom(Value&& value) { *this = value; }
      void setTextMessage(const char* text_message) { *this = Value(text_message); }
  
      uint16_t getValueLength() const { return static_cast<uint16_t>(m_value.length()); }
  
      bool operator==(const Value& other) const noexcept { return Common::StrcmpCompare::isEqual(this->m_value, other.m_value); }
      bool operator!=(const Value& other) const noexcept { return Common::StrcmpCompare::isNotEqual(this->m_value, other.m_value); }
      // No ordering operators
  
      std::string toString() const;
  
      friend std::ostream& operator<<(std::ostream& output, const Value& value) { output << value.toString(); return output; }
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const Value& value);
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, Value& value);
  
    private:
      std::string m_value;
  
      void checkSize()
      {
        // vvv--- YOU CAN PUT VALUE CHECK HANDLING HERE
        if (getValueLength() > max_length)
        {
          throw Common::ConversionError(m_value, "too long string to initiate Configuration::Value");
        }
        // ^^^--- END OF VALUE CHECK HANDLING HERE
      }
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Configuration

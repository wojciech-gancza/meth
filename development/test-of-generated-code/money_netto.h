// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/money_netto.h
// and it is generated by:      .../test.py[107]
// based on pattern file:       .../patterns/float.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <format>
#include <string>
#include <iostream>

#include "serialization_binary_serialization.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Money
{
  static_assert(sizeof(float) == 4);
  static_assert(sizeof(double) == 8);
  
  class Netto
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Money::Netto" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      static constexpr float compare_accuracy = { /* +/- */ 0.005f };
  
      Netto() noexcept
      : m_netto(0.0)
      {  }
      
      constexpr explicit Netto(float netto) noexcept
      : m_netto(netto)
      {  }
      
      Netto(const Netto& netto) noexcept = default;
      Netto(Netto&& netto) noexcept = default;
      Netto& operator=(const Netto& netto) noexcept = default;
      Netto& operator=(Netto&& netto) noexcept = default;
  
      float getNettoAsFloat() const noexcept { return m_netto; }
  
      const Netto& getNetto() const noexcept { return *this; }
      
      void setNetto(const Netto& netto) { *this = netto; }
      void setNetto(float netto) { *this = Netto(netto); }
      void setFrom(const Netto& netto) { *this = netto; }
      void setFrom(Netto&& netto) { *this = netto; }
  
      bool operator==(const Netto& other) const noexcept { return abs(m_netto - other.m_netto) <= compare_accuracy; }
      bool operator!=(const Netto& other) const noexcept { return !operator==(other); }
      bool operator<(const Netto& other) const noexcept { return (m_netto < other.m_netto) && operator!=(other); }
      bool operator<=(const Netto& other) const noexcept { return (m_netto < other.m_netto) || operator==(other); }
      bool operator>=(const Netto& other) const noexcept { return (m_netto > other.m_netto) || operator==(other); }
      bool operator>(const Netto& other) const noexcept { return (m_netto > other.m_netto) && operator!=(other); }
  
      std::string toString() const { return std::format("{:.2f}", m_netto); }
  
      static Netto fromString(const std::string& text);
  
      friend std::ostream& operator<<(std::ostream& output, const Netto& netto) { output << netto.toString(); return output; }
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const Netto& netto)
      {
        output.storeValue(netto.m_netto);
        return output;
      }
      
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, Netto& netto)
      {
        input.readValue(netto.m_netto);
        return input;
      }
  
    private:
      float m_netto;
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Money

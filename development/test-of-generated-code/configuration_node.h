// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/test-of-generated-code/configuration_node.h
// and it is generated by:      .../generator.py[264]
// based on pattern file:       .../patterns/record.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <string>
#include <iostream>
#include "configuration_key.h"
#include "configuration_value.h"
#include "configuration_nodes.h"
#include "serialization_binary_serialization.h"

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Configuration
{
  class Node 
    : public Configuration::Key
    , public Configuration::Value
    , public Configuration::Nodes
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Configuration::Node" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
  
      typedef std::unique_ptr<Node> Owner;
  
      Node() = default;
  
      Node(const Node& node) noexcept
      : Configuration::Key(node)
      , Configuration::Value(node)
      , Configuration::Nodes(node)
      {  }
  
      Node(Node&& node) noexcept
      : Configuration::Key(node)
      , Configuration::Value(node)
      , Configuration::Nodes(node)
      {  }
  
      Node(const Configuration::Key& configuration_key,
           const Configuration::Value& configuration_value,
           const Configuration::Nodes& configuration_nodes) noexcept
      : Configuration::Key(configuration_key)
      , Configuration::Value(configuration_value)
      , Configuration::Nodes(configuration_nodes)
      {  }
  
      Node(Configuration::Key&& configuration_key,
           Configuration::Value&& configuration_value,
           Configuration::Nodes&& configuration_nodes) noexcept
      : Configuration::Key(configuration_key)
      , Configuration::Value(configuration_value)
      , Configuration::Nodes(configuration_nodes)
      {  }
  
      Node& operator=(const Node& node) noexcept = default;
      Node& operator=(Node&& node) noexcept = default;
  
      template <class OTHER>
      void setFrom(const OTHER& other)
      {
        if constexpr(std::is_base_of_v<Configuration::Key, OTHER>)
        {
          Configuration::Key::setFrom(other);
        }
        else if constexpr(std::is_base_of_v<OTHER, Configuration::Key>)
        {
          Configuration::Key::setFrom(other);
        }
        if constexpr(std::is_base_of_v<Configuration::Value, OTHER>)
        {
          Configuration::Value::setFrom(other);
        }
        else if constexpr(std::is_base_of_v<OTHER, Configuration::Value>)
        {
          Configuration::Value::setFrom(other);
        }
        if constexpr(std::is_base_of_v<Configuration::Nodes, OTHER>)
        {
          Configuration::Nodes::setFrom(other);
        }
        else if constexpr(std::is_base_of_v<OTHER, Configuration::Nodes>)
        {
          Configuration::Nodes::setFrom(other);
        }
      }
  
      template <class OTHER>
      void setFrom(OTHER&& other)
      {
        if constexpr(std::is_base_of_v<typename std::remove_reference<OTHER>::type, Configuration::Key>)
        {
          Configuration::Key::setFrom(other);
        }
        else if constexpr(std::is_base_of_v<Configuration::Key, typename std::remove_reference<OTHER>::type>)
        {
          Configuration::Key::setFrom(other);
        }
        if constexpr(std::is_base_of_v<typename std::remove_reference<OTHER>::type, Configuration::Value>)
        {
          Configuration::Value::setFrom(other);
        }
        else if constexpr(std::is_base_of_v<Configuration::Value, typename std::remove_reference<OTHER>::type>)
        {
          Configuration::Value::setFrom(other);
        }
        if constexpr(std::is_base_of_v<typename std::remove_reference<OTHER>::type, Configuration::Nodes>)
        {
          Configuration::Nodes::setFrom(other);
        }
        else if constexpr(std::is_base_of_v<Configuration::Nodes, typename std::remove_reference<OTHER>::type>)
        {
          Configuration::Nodes::setFrom(other);
        }
      }
  
      bool operator==(const Node& node) const noexcept;
      bool operator!=(const Node& node) const noexcept;
      bool operator<(const Node& node) const noexcept;
      bool operator<=(const Node& node) const noexcept;
      bool operator>=(const Node& node) const noexcept;
      bool operator>(const Node& node) const noexcept;
  
      std::string toString() const;
  
      friend std::ostream& operator<<(std::ostream& output, const Node& node);
  
      friend Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& output, const Node& node);
      friend Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& input, Node& node);
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
} // end Configuration

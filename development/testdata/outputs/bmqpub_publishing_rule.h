// --------------------------------------------------------------------------------------
// File generated by metamorph meth code generator. File may be modified only inside 
// specially marked code blocks. Only such code can survive during subsequent generation 
// of the file. All other modification can be overwritten when generator is started.
// --------------------------------------------------------------------------------------
// This file is stored at:      .../development/testdata/outputs/bmqpub_publishing_rule.h
// and it is generated by:      .../generator.py[182]
// based on pattern file:       .../patterns/enum.h.body.pattern
// wrapped by pattern:          .../patterns/common.main.pattern
// (where '...' is solution root path)
// --------------------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <string>
#include <iostream>

// vvv--- YOU CAN PUT ADDITIONAL INCLUDES BELOW

// ^^^--- END OF USER DEFINED INCLUDES

namespace Bmqpub
{
  class PublishingRule
  {
    public:
      // type traits
      static constexpr const char* class_name = { "Bmqpub::PublishingRule" };
      static constexpr bool is_compareable = { true };
      static constexpr bool is_ordered = { true };
      static constexpr bool size_in_bytes = { 1 };
  
      // internal value type
      enum ePublishingRule : uint8_t 
      {
        E_UNKNOWN,
        E_VALIDONCE,
        E_VALIDALWAYS,
        E_ANYALWAYS
      };
  
      static constexpr ePublishingRule first_value = { E_UNKNOWN };
      static constexpr ePublishingRule last_value = { E_ANYALWAYS } ;
  
      PublishingRule() noexcept
      : m_publishing_rule(E_UNKNOWN)
      {  }
      
      constexpr explicit PublishingRule(ePublishingRule publishing_rule) noexcept
      : m_publishing_rule(publishing_rule)
      {  }
      
      PublishingRule(const PublishingRule& publishing_rule) noexcept = default;
      PublishingRule(PublishingRule&& publishing_rule) noexcept = default;
      PublishingRule& operator=(const PublishingRule& publishing_rule) noexcept = default;
      PublishingRule& operator=(PublishingRule&& publishing_rule) noexcept = default;
  
      ePublishingRule getPublishingRuleAsEnum() const noexcept { return m_publishing_rule; }
      uint8_t getPublishingRuleAsInt() const noexcept { return m_publishing_rule; }
  
      const PublishingRule& getPublishingRule() const noexcept { return *this; }
      
      void setPublishingRule(const PublishingRule& publishing_rule) { *this = publishing_rule; }
      void setPublishingRule(ePublishingRule publishing_rule) { *this = PublishingRule(publishing_rule); }
      void setFrom(const PublishingRule& publishing_rule) { *this = publishing_rule; }
      void setFrom(PublishingRule&& publishing_rule) { *this = publishing_rule; }
  
      bool operator==(const PublishingRule& publishing_rule) const noexcept { return (m_publishing_rule == publishing_rule.m_publishing_rule); }
      bool operator!=(const PublishingRule& publishing_rule) const noexcept { return (m_publishing_rule != publishing_rule.m_publishing_rule); }
      bool operator<(const PublishingRule& publishing_rule) const noexcept { return (m_publishing_rule < publishing_rule.m_publishing_rule); }
      bool operator<=(const PublishingRule& publishing_rule) const noexcept { return (m_publishing_rule <= publishing_rule.m_publishing_rule); }
      bool operator>=(const PublishingRule& publishing_rule) const noexcept { return (m_publishing_rule >= publishing_rule.m_publishing_rule); }
      bool operator>(const PublishingRule& publishing_rule) const noexcept { return (m_publishing_rule > publishing_rule.m_publishing_rule); }
  
      std::string toString() const;
      static PublishingRule fromString(const std::string& text);
      
      friend std::ostream& operator<<(std::ostream& output, const PublishingRule& publishing_rule);
  
    private:
      ePublishingRule m_publishing_rule;
  
      static const char* m_publishing_rule_names[];
  
      static ePublishingRule convertTextToPossibleEnum(const std::string& text) noexcept;
  
      // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW
  
      // ^^^--- END OF USER DEFINED CLASS ELEMENTS
  };
  
  constexpr PublishingRule UNKNOWN { PublishingRule(PublishingRule::E_UNKNOWN) };
  constexpr PublishingRule VALIDONCE { PublishingRule(PublishingRule::E_VALIDONCE) };
  constexpr PublishingRule VALIDALWAYS { PublishingRule(PublishingRule::E_VALIDALWAYS) };
  constexpr PublishingRule ANYALWAYS { PublishingRule(PublishingRule::E_ANYALWAYS) };

} // end Bmqpub

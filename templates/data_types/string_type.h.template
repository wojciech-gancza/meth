${#INCLUDE _file_header.part}

#pragma once

#include <string>
#include <sstream>
#include <assert.h>

${#INCLUDE _tools_includes.part}
#include "${tools_path}meth_toolbox_strings.h"

// -vvv YOU CAN PUT ADDITIONAL INCLUDES BELOW

// -^^^ END OF USER DEFINED INCLUDES

namespace ${namespace}
{
  class ${class_name}
  {
    public:
${#INCLUDE _type_traits.part}
      static constexpr size_t max_length { ${max_length} };

      explicit ${class_name}(const std::string& ${field_name}) noexcept   : m_${field_name}(${field_name}) { checkValue(); }
      explicit ${class_name}(std::string&& ${field_name}) noexcept   : m_${field_name}(${field_name}) { checkValue(); }
      ${class_name}() noexcept    ${#IF default_value}: m_${field_name}("${default_value}") ${#END}{  }
      ${class_name}(const ${class_name}& ${field_name}) noexcept    : m_${field_name}(${field_name}.m_${field_name}) {  }
      ${class_name}(${class_name}&& ${field_name}) noexcept    : m_${field_name}(${field_name}.m_${field_name}) {  }
      
      const std::string& get${class_name}() const noexcept   { return m_${field_name}; }
      void set${class_name}(const std::string& ${field_name}) noexcept    { m_${field_name} = ${field_name}; }
      void set${class_name}(std::string&& ${field_name}) noexcept    { m_${field_name} = ${field_name}; }

      void setFrom(const ${class_name}& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; }
      void setFrom(${class_name}&& ${field_name}) noexcept    { m_${field_name} = std::move(${field_name}.m_${field_name}); }

      ${class_name}& operator=(const ${class_name}& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; return *this; }
      ${class_name}& operator=(${class_name}&& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; return *this; }

      bool is${class_name}Empty() const     { return m_${field_name}.empty(); }

      // -vvv YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

${#INCLUDE _ordering_relations.part}
${#IF compareable}
      bool isEqual(const ${class_name}& other) const    { return MethToolbox::Strings::strcmp${compare_strategy}(m_${field_name}, other.m_${field_name}) == MethToolbox::EQUAL; }
${#IF ordered}
      MethToolbox::CompareResult compareWith(const ${class_name}& other) const    { return MethToolbox::Strings::strcmp${compare_strategy}(m_${field_name}, other.m_${field_name}); }
${#END}

${#END}
      friend std::ostream& operator<<(std::ostream& out, const ${class_name}& ${field_name})    { out << MethToolbox::Strings::encodeString(${field_name}.m_${field_name}); return out; }

      friend MethToolbox::SerializationInterface& operator<<(MethToolbox::SerializationInterface& serializer, const ${class_name}& ${field_name})    { serializer.serialize${length_cathegory}String(${field_name}.m_${field_name}); return serializer; }
      friend MethToolbox::DeserializationInterface& operator>>(MethToolbox::DeserializationInterface& deserializer, ${class_name}& ${field_name})    { deserializer.deserialize${length_cathegory}String(${field_name}.m_${field_name}); ${#IF range_controll}${field_name}.checkValue(); ${#END}return deserializer; }

      std::string toString() const    { std::stringstream buffer; buffer << *this; return buffer.str(); }
      static ${class_name} fromString(const std::string& text)    { return ${class_name}(MethToolbox::Strings::decodeString(text)); }

    private:
      std::string m_${field_name};

      void checkValue()
      {
        assert(m_${field_name}.size() < max_length);

        // -vvv YOU CAN PUT RUNTIME VALUE ERROR HANDLING HERE REPLACING DEFAULT EXCEPTION

        if(m_${field_name}.size() >= max_length)
        {
          throw MethToolbox::ValueError();
        }

        // -^^^ YOU CAN PUT RUNTIME VALUE ERROR HANDLING HERE REPLACING DEFAULT EXCEPTION
      }

      // -vvv YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  };
}

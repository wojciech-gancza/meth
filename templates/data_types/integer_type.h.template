${#INCLUDE _file_header.part}

#pragma once

#include <sstream>
${#IF ${range_controll}}
#include <assert.h>
${#END}

${#INCLUDE _tools_includes.part}

// -vvv YOU CAN PUT ADDITIONAL INCLUDES BELOW

// -^^^ END OF USER DEFINED INCLUDES

namespace ${namespace}
{
  class ${class_name}
  {
    public:
${#INCLUDE _type_traits.part}
      static constexpr uint8_t size_in_bytes = sizeof(${base_type});
${#IF ${range_controll}}
      static constexpr ${base_type} min_value { ${min_value} };
      static constexpr ${base_type} max_value { ${max_value} };
${#END}

      explicit ${class_name}(${base_type} ${field_name}) noexcept   : m_${field_name}(${field_name}) { ${#IF range_controll}checkValue();${#END} }
      ${class_name}() noexcept    : m_${field_name}(${default_value}) {  }
      ${class_name}(const ${class_name}& ${field_name}) noexcept    : m_${field_name}(${field_name}.m_${field_name}) {  }
      ${class_name}(${class_name}&& ${field_name}) noexcept    : m_${field_name}(${field_name}.m_${field_name}) {  }
      
      ${base_type} get${class_name}AsInteger() const noexcept   { return m_${field_name}; }
      void set${class_name}(${base_type} ${field_name}) noexcept    { m_${field_name} = ${field_name}; }

      void setFrom(const ${class_name}& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; }
      void setFrom(${class_name}&& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; }

      ${class_name}& operator=(const ${class_name}& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; return *this; }
      ${class_name}& operator=(${class_name}&& ${field_name}) noexcept    { m_${field_name} = ${field_name}.m_${field_name}; return *this; }
${#IF increment}

      ${class_name}& operator++() { ++m_${field_name}; ${#IF range_controll}checkValue(); ${#END}return *this; }
      ${class_name} operator++(int) { ${class_name} ${field_name}(*this); ++(*this); return ${field_name}; }
${#END}
${#IF decrement}

      ${class_name}& operator--() { --m_${field_name}; ${#IF range_controll}checkValue(); ${#END}return *this; }
      ${class_name} operator--(int) { ${class_name} ${field_name}(*this); --(*this); return ${field_name}; }
${#END}

      // -vvv YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

${#INCLUDE _int_ordering_relations.part}
      friend std::ostream& operator<<(std::ostream& out, const ${class_name}& ${field_name})    { out << ${#IF need_promotion}static_cast<int>(${field_name}.m_${field_name})${#ELSE}${field_name}.m_${field_name}${#END}; return out; }

      friend MethToolbox::SerializationInterface& operator<<(MethToolbox::SerializationInterface& serializer, const ${class_name}& ${field_name})    { serializer.serializeInteger(${field_name}.m_${field_name}); return serializer; }
      friend MethToolbox::DeserializationInterface& operator>>(MethToolbox::DeserializationInterface& deserializer, ${class_name}& ${field_name})    { deserializer.deserializeInteger(${field_name}.m_${field_name}); ${#IF range_controll}${field_name}.checkValue(); ${#END}return deserializer; }

      std::string toString() const    { std::stringstream buffer; buffer << *this; return buffer.str(); }
      static ${class_name} fromString(const std::string& text)    
      { 
        ${base_type} ${field_name};
        std::stringstream buffer(text);
${#IF base_type == 'uint8_t'}
        uint16_t temp = 0;
        buffer >> temp;
        if (temp > 255)
        {
          throw MethToolbox::ValueError();
        }
        else
        {
          ${field_name} = static_cast<${base_type}>(temp);
        }
${#ELSE}
${#IF base_type == 'int8_t'}
        int16_t temp = 0;
        buffer >> temp;
        if (temp > 127 || temp < -128)
        {
          throw MethToolbox::ValueError();
        }
        else
        {
          ${field_name} = static_cast<${base_type}>(temp);
        }
${#ELSE}
        buffer >> ${field_name};
${#END}
${#END}
        char c = 0;
        if (buffer.fail() || buffer.get(c))
        {
          throw MethToolbox::ValueError();
        }
        return ${class_name}(${field_name}); 
      }

    private:
      ${base_type} m_${field_name};

${#IF range_controll}
      void checkValue()
      {
        assert(m_${field_name} >= min_value);
        assert(m_${field_name} <= max_value);

        // -vvv YOU CAN PUT RUNTIME VALUE ERROR HANDLING HERE REPLACING DEFAULT EXCEPTION

        if(m_${field_name} < min_value || m_${field_name} > max_value)
        {
          throw MethToolbox::ValueError();
        }

        // -^^^ YOU CAN PUT RUNTIME VALUE ERROR HANDLING HERE REPLACING DEFAULT EXCEPTION
      }

${#END}
      // -vvv YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  };
}

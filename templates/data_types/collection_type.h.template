${#INCLUDE _file_header.part}

#pragma once

${#IF export_definition_include}
#include "${export_definition_include}"

${#END}
#include <vector>

${#INCLUDE _tools_includes.part}

// -vvv YOU CAN PUT ADDITIONAL INCLUDES BELOW

// -^^^ END OF USER DEFINED INCLUDES

#pragma warning(disable: 4275)

namespace ${namespace} 
{
  class ${element_class_name};

  class ${class_name}
  {
    public:
${#INCLUDE _type_traits.part}
      typedef ${element_class_name} ElementType;
      typedef ${size_type} SizeType;
${#IF max_size}
      static constexpr SizeType max_size = ${max_size};
${#END}
      typedef std::unique_ptr<${class_name}> Owner;
      typedef ${class_name}& Reference;

    public:
      ${class_name}() = default;
      ${class_name}(const ${class_name}& ${field_name}) = default;
      ${class_name}(${class_name}&& ${field_name}) noexcept = default;

      void setFrom(const ${class_name}& other)    { m_${field_name} = other.m_${field_name}; }
      void setFrom(${class_name}&& other)    { m_${field_name} = other.m_${field_name}; }

      ${#IF export_specifier}${export_specifier} ${#END}${element_class_name}& new${element_class_name}();
      ${#IF export_specifier}${export_specifier} ${#END}${element_class_name}& add${element_class_name}(const ${element_class_name}& element);
      ${#IF export_specifier}${export_specifier} ${#END}${element_class_name}& add${element_class_name}(${element_class_name}&& element);

      ${element_class_name}& get${element_class_name}(SizeType index)    { return m_${field_name}[index]; }
      const ${element_class_name}& get${element_class_name}(SizeType index) const     { return m_${field_name}[index]; }

      SizeType get${class_name}Size() const     { return static_cast<SizeType>(m_${field_name}.size()); }

      void clear${class_name}()    { m_${field_name}.clear(); }

      ${#IF export_specifier}${export_specifier} ${#END}void remove${element_class_name}(SizeType index);
      template <class KEY> SizeType removeFrom${class_name}(KEY key)
      {
        SizeType erased_count = 0;
        SizeType index = 0;
        while(index < get${class_name}Size())
        {
          if (key == m_nodes[index])
          {
            remove${element_class_name}(index);
            ++erased_count;
          }
          else
          {
            ++index;
          }
        }
        return erased_count;
      }

      ${class_name}& operator=(const ${class_name}& ${field_name}) noexcept    { setFrom(${field_name}); return *this; };
      ${class_name}& operator=(${class_name}&& ${field_name}) noexcept    { setFrom(${field_name}); return *this; };

      friend ${#IF export_specifier}${export_specifier} ${#END}std::ostream& operator<<(std::ostream& out, const ${class_name}& object);
    
      friend ${#IF export_specifier}${export_specifier} ${#END}MethToolbox::SerializationInterface& operator<<(MethToolbox::SerializationInterface& serializer, const ${class_name}& object);
      friend ${#IF export_specifier}${export_specifier} ${#END}MethToolbox::DeserializationInterface& operator>>(MethToolbox::DeserializationInterface& deserializer, ${class_name}& object);

      std::string toString() const { std::ostringstream buffer; buffer << *this; return buffer.str(); }

${#INCLUDE _ordering_relations.part}
${#IF compareable}
      bool ${#IF export_specifier}${export_specifier} ${#END}isEqual(const ${class_name}& other) const;
${#IF ordered}
      MethToolbox::CompareResult ${#IF export_specifier}${export_specifier} ${#END}compareWith(const ${class_name}& other) const;
${#END}

${#END}
      // -vvv YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

      class Iterator;
      class ConstIterator;
      class ReverseIterator;
      class ConstReverseIterator;

      Iterator get${class_name}Begin()    { return Iterator(*this, 0); }
      Iterator get${class_name}End()    { return Iterator(*this, get${class_name}Size()); }
      ConstIterator get${class_name}Begin() const    { return ConstIterator(*this, 0); }
      ConstIterator get${class_name}End() const    { return ConstIterator(*this, get${class_name}Size()); }
      ConstIterator get${class_name}CBegin() const    { return ConstIterator(*this, 0); }
      ConstIterator get${class_name}CEnd() const    { return ConstIterator(*this, get${class_name}Size()); }
      ReverseIterator get${class_name}RBegin()    { return ReverseIterator(*this, get${class_name}Size() - 1); }
      ReverseIterator get${class_name}REnd()    { return ReverseIterator(*this, SizeType(-1)); }
      ConstReverseIterator get${class_name}RBegin() const    { return ConstReverseIterator(*this, get${class_name}Size() - 1); }
      ConstReverseIterator get${class_name}REnd() const    { return ConstReverseIterator(*this, SizeType(-1)); }
      ConstReverseIterator get${class_name}CRBegin() const    { return ConstReverseIterator(*this, get${class_name}Size() - 1); }
      ConstReverseIterator get${class_name}CREnd() const    { return ConstReverseIterator(*this, SizeType(-1)); }

      ${#INCLUDE _collection_iterator.part "iterator_name":"Iterator", "iterator_collection_type":"${class_name}", "iterator_item_type":"${element_class_name}", "inc":"+", "dec":"-", "le":"<", "gt":">", "corrected_position":"m_position", "other_corrected_position":"other.m_position" }

      ${#INCLUDE _collection_iterator.part "iterator_name":"ReverseIterator", "iterator_collection_type":"${class_name}", "iterator_item_type":"${element_class_name}", "inc":"-", "dec":"+", "le":">", "gt":"<", "corrected_position":"(m_position + 1)", "other_corrected_position":"(other.m_position + 1)" }

      ${#INCLUDE _collection_iterator.part "iterator_name":"ConstIterator", "iterator_collection_type":"const ${class_name}", "iterator_item_type":"const ${element_class_name}", "inc":"+", "dec":"-", "le":"<", "gt":">", "corrected_position":"m_position", "other_corrected_position":"other.m_position" }

      ${#INCLUDE _collection_iterator.part "iterator_name":"ConstReverseIterator", "iterator_collection_type":"const ${class_name}", "iterator_item_type":"const ${element_class_name}", "inc":"-", "dec":"+", "le":">", "gt":"<", "corrected_position":"(m_position + 1)", "other_corrected_position":"(other.m_position + 1)" }

    private:
      std::vector<${element_class_name}> m_${field_name};

      // -vvv YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  };
} 

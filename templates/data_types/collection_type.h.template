${#INCLUDE _file_header.part}

#pragma once

${#IF export_definition_include}
#include "${export_definition_include}"

${#END}
#include <vector>

${#INCLUDE _tools_includes.part}

// -vvv YOU CAN PUT ADDITIONAL INCLUDES BELOW

// -^^^ END OF USER DEFINED INCLUDES

#pragma warning(disable: 4275)

namespace ${namespace} 
{
  class ${element_class_name};

  class ${class_name}
  {
    public:
${#INCLUDE _type_traits.part}
      typedef ${element_class_name} ElementType;
      typedef ${size_type} SizeType;
${#IF max_size}
      static constexpr SizeType max_size = ${max_size};
${#END}
      typedef std::unique_ptr<${class_name}> Owner;
      typedef ${class_name}& Reference;

    public:
      ${class_name}() = default;
      ${class_name}(const ${class_name}& ${field_name}) = default;
      ${class_name}(${class_name}&& ${field_name}) noexcept = default;

      void setFrom(const ${class_name}& other)    { m_${field_name} = other.m_${field_name}; }
      void setFrom(${class_name}&& other)    { m_${field_name} = other.m_${field_name}; }

      ${#IF export_specifier}${export_specifier} ${#END}${element_class_name}& new${element_class_name}();
      ${#IF export_specifier}${export_specifier} ${#END}${element_class_name}& add${element_class_name}(const ${element_class_name}& element);
      ${#IF export_specifier}${export_specifier} ${#END}${element_class_name}& add${element_class_name}(${element_class_name}&& element);

      ${element_class_name}& get${element_class_name}(SizeType index)    { return m_${field_name}[index]; }
      const ${element_class_name}& get${element_class_name}(SizeType index) const     { return m_${field_name}[index]; }

      SizeType get${class_name}Size() const     { return static_cast<SizeType>(m_${field_name}.size()); }

      void clear${class_name}()    { m_${field_name}.clear(); }

      ${#IF export_specifier}${export_specifier} ${#END}void remove${element_class_name}(SizeType index);
      template <class KEY> SizeType removeFrom${class_name}(KEY key)
      {
        SizeType erased_count = 0;
        SizeType index = 0;
        while(index < get${class_name}Size())
        {
          if (key == m_nodes[index])
          {
            remove${element_class_name}(index);
            ++erased_count;
          }
          else
          {
            ++index;
          }
        }
        return erased_count;
      }

      ${class_name}& operator=(const ${class_name}& ${field_name}) noexcept    { setFrom(${field_name}); return *this; };
      ${class_name}& operator=(${class_name}&& ${field_name}) noexcept    { setFrom(${field_name}); return *this; };

      friend ${#IF export_specifier}${export_specifier} ${#END}std::ostream& operator<<(std::ostream& out, const ${class_name}& object);
    
      friend ${#IF export_specifier}${export_specifier} ${#END}MethToolbox::SerializationInterface& operator<<(MethToolbox::SerializationInterface& serializer, const ${class_name}& object);
      friend ${#IF export_specifier}${export_specifier} ${#END}MethToolbox::DeserializationInterface& operator>>(MethToolbox::DeserializationInterface& deserializer, ${class_name}& object);

      std::string toString() const { std::ostringstream buffer; buffer << *this; return buffer.str(); }

${#INCLUDE _ordering_relations.part}
${#IF compareable}
      bool ${#IF export_specifier}${export_specifier} ${#END}isEqual(const ${class_name}& other) const;
${#IF ordered}
      MethToolbox::CompareResult ${#IF export_specifier}${export_specifier} ${#END}compareWith(const ${class_name}& other) const;
${#END}

${#END}
      // -vvv YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PUBLIC METHODS HERE

      ${#INCLUDE _collection_search.part "resultset_name":"SearchResult", "is_result_const":False }

      ${#INCLUDE _collection_search.part "resultset_name":"SearchResultConst", "is_result_const":True }

      ${#INCLUDE _collection_iteration.part "iterated_class_name":"${class_name}", "element_mutable_class_name":"${element_class_name}", "element_const_class_name":"const ${element_class_name}", }

    private:
      std::vector<${element_class_name}> m_${field_name};

      // -vvv YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE

      // -^^^ YOU CAN PUT ADDITIONAL PRIVATE METHODS AND FIELDS HERE
  };
} 

static_assert(sizeof(float) == 4);
static_assert(sizeof(double) == 8);

class ${class_name}
{
  public:
    // type traits
    static constexpr const char* class_name = { "${name.FullyDecoratedClassName()}" };
    static constexpr bool is_compareable = { ${#if compareable}true${#else}false${#end} };
    static constexpr bool is_ordered = { ${#if ordered}true${#else}false${#end} };
    static constexpr ${float_class} compare_accuracy = { /* +/- */ ${accuracy} };

    constexpr ${class_name}() noexcept
      : m_${object_name}(${default})
    {  }

    constexpr explicit ${class_name}( ${float_class} ${object_name} ) noexcept
      : m_${object_name}(${object_name})
    {  }

    ${#include "simple.assignment.pattern"}

    ${#include "simple.getter.setter.pattern" "simple_type_name": "Float", "simple_type": float_class, "extra_check_code": ""}

${#if compareable}    bool operator==(const ${class_name}& other) const noexcept { return abs(m_${object_name} - other.m_${object_name}) <= compare_accuracy; }
    bool operator!=(const ${class_name}& other) const noexcept { return !operator==(other); }${#else}    // No compare operators${#end}
${#if ordered}    bool operator<(const ${class_name}& other) const noexcept { return (m_${object_name} < other.m_${object_name}) && operator!=(other); }
    bool operator<=(const ${class_name}& other) const noexcept { return (m_${object_name} < other.m_${object_name}) || operator==(other); }
    bool operator>=(const ${class_name}& other) const noexcept { return (m_${object_name} > other.m_${object_name}) || operator==(other); }
    bool operator>(const ${class_name}& other) const noexcept { return (m_${object_name} > other.m_${object_name}) && operator!=(other); }${#else}    // No ordering operators${#end}

    std::string toString() const { return std::format("{:${string_format}f}", m_${object_name}); }

    static ${class_name} fromString(const std::string& text);
        
    friend std::ostream& operator<<(std::ostream& output, const ${class_name}& ${object_name}) { output << ${object_name}.toString(); return output; }
    
    ${#include "value.binary.serialization.pattern"}

  private:
    ${float_class} m_${object_name};

    // -vvv YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW

    // -^^^ END OF USER DEFINED CLASS ELEMENTS
};
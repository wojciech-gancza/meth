static_assert(sizeof(float) == 4);
static_assert(sizeof(double) == 8);

class ${class_name}
{
  public:
    // type traits
    ${#include "common.traits.pattern"}
    static constexpr ${float_class} compare_accuracy = { /* +/- */ ${accuracy} };

    ${#include "simple.construction.pattern"}

    ${float_class} get${class_name}AsFloat() const noexcept { return m_${object_name}; }

    ${#include "simple.getters.setters.pattern"}

${#if compareable}    bool operator==(const ${class_name}& other) const noexcept { return abs(m_${object_name} - other.m_${object_name}) <= compare_accuracy; }
    bool operator!=(const ${class_name}& other) const noexcept { return !operator==(other); }${#else}    // No compare operators${#end}
${#if ordered}    bool operator<(const ${class_name}& other) const noexcept { return (m_${object_name} < other.m_${object_name}) && operator!=(other); }
    bool operator<=(const ${class_name}& other) const noexcept { return (m_${object_name} < other.m_${object_name}) || operator==(other); }
    bool operator>=(const ${class_name}& other) const noexcept { return (m_${object_name} > other.m_${object_name}) || operator==(other); }
    bool operator>(const ${class_name}& other) const noexcept { return (m_${object_name} > other.m_${object_name}) && operator!=(other); }${#else}    // No ordering operators${#end}

    std::string toString() const { return std::format("{:${string_format}f}", m_${object_name}); }

    static ${class_name} fromString(const std::string& text);

    friend std::ostream& operator<<(std::ostream& output, const ${class_name}& ${object_name}) { output << ${object_name}.toString(); return output; }

    ${#include "simple.value.serialization.pattern"}

  private:
    ${float_class} m_${object_name};

    // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW

    // ^^^--- END OF USER DEFINED CLASS ELEMENTS
};
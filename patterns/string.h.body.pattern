class ${class_name}
{
  public:
    // type traits
    ${#include "common.traits.pattern"}
    static constexpr ${int_class} max_length = { ${max_size} };

    explicit ${class_name}(const char* ${object_name})
    : m_${object_name}(${object_name})
    {  }

    explicit ${class_name}(std::string&& ${object_name})
    : m_${object_name}(${object_name})
    {  }

    ${#include "simple.construction.pattern"}

    std::string get${class_name}AsString() const noexcept { return m_${object_name}; }

    ${#include "simple.getters.setters.pattern"}
    void setTextMessage(const char* text_message) { *this = ${class_name}(text_message); }

    ${int_class} get${class_name}Length() const { return static_cast<${int_class}>(m_${object_name}.length()); }

${#if compareable}    bool operator==(const ${class_name}& other) const noexcept { return ${compare_class.FullyDecoratedClassName()}::isEqual(this->m_${object_name}, other.m_${object_name}); }
    bool operator!=(const ${class_name}& other) const noexcept { return ${compare_class.FullyDecoratedClassName()}::isNotEqual(this->m_${object_name}, other.m_${object_name}); }${#else}    // No compare operators${#end}
${#if ordered}    bool operator<(const ${class_name}& other) const noexcept { return ${compare_class.FullyDecoratedClassName()}::isLower(this->m_${object_name}, other.m_${object_name}); }
    bool operator<=(const ${class_name}& other) const noexcept { return ${compare_class.FullyDecoratedClassName()}::isLowerOrEqual(this->m_${object_name}, other.m_${object_name}); }
    bool operator>=(const ${class_name}& other) const noexcept { return ${compare_class.FullyDecoratedClassName()}::isAboveOrEqual(this->m_${object_name}, other.m_${object_name}); }
    bool operator>(const ${class_name}& other) const noexcept { return ${compare_class.FullyDecoratedClassName()}::isAbove(this->m_${object_name}, other.m_${object_name}); }${#else}    // No ordering operators${#end}

    std::string toString() const;

    friend std::ostream& operator<<(std::ostream& output, const ${class_name}& ${object_name}) { output << ${object_name}.toString(); return output; }

    ${#include "simple.value.serialization.declaration.pattern"}

  private:
    std::string m_${object_name};

    void checkSize()
    {
      // vvv--- YOU CAN PUT VALUE CHECK HANDLING HERE
      if (get${class_name}Length() > max_length)
      {
        throw Common::ConversionError(m_${object_name}, "too long string to initiate ${name.FullyDecoratedClassName()}");
      }
      // ^^^--- END OF VALUE CHECK HANDLING HERE
    }

    // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW

    // ^^^--- END OF USER DEFINED CLASS ELEMENTS
};
class ${class_name} 
  ${format.inheritance_list(["public " + value.FullyDecoratedClassName() for value in values])}
{
  public:
    // type traits
    ${#include "common.traits.pattern"}

    typedef std::unique_ptr<${class_name}> Owner;

    ${class_name}() = default;

    ${class_name}(const ${class_name}& ${object_name}) noexcept
    ${format.inheritance_list([value.FullyDecoratedClassName() + "(" + object_name + ")" for value in values])}
    {  }

    ${class_name}(${class_name}&& ${object_name}) noexcept
    ${format.inheritance_list([value.FullyDecoratedClassName() + "(" + object_name + ")" for value in values])}
    {  }

    ${class_name}(${format.comma_separated(["const " + value.FullyDecoratedClassName() + "& " + value.lowercase_namespace_and_name() for value in values])}) noexcept
    ${format.inheritance_list([value.FullyDecoratedClassName() + "(" + value.lowercase_namespace_and_name() + ")" for value in values])}
    {  }

    ${class_name}(${format.comma_separated([value.FullyDecoratedClassName() + "&& " + value.lowercase_namespace_and_name() for value in values])}) noexcept
    ${format.inheritance_list([value.FullyDecoratedClassName() + "(" + value.lowercase_namespace_and_name() + ")" for value in values])}
    {  }

    ${class_name}& operator=(const ${class_name}& ${object_name}) noexcept = default;
    ${class_name}& operator=(${class_name}&& ${object_name}) noexcept = default;

    template <class OTHER>
    void setFrom(const OTHER& other)
    {${#for value : values}
      if constexpr(std::is_base_of_v<${value.FullyDecoratedClassName()}, OTHER>)
      {
        ${value.FullyDecoratedClassName()}::setFrom(other);
      }
      else if constexpr(std::is_base_of_v<OTHER, ${value.FullyDecoratedClassName()}>)
      {
        ${value.FullyDecoratedClassName()}::setFrom(other);
      }${#end}
    }

    template <class OTHER>
    void setFrom(OTHER&& other)
    {${#for value in values}
      if constexpr(std::is_base_of_v<typename std::remove_reference<OTHER>::type, ${value.FullyDecoratedClassName()}>)
      {
        ${value.FullyDecoratedClassName()}::setFrom(other);
      }
      else if constexpr(std::is_base_of_v<${value.FullyDecoratedClassName()}, typename std::remove_reference<OTHER>::type>)
      {
        ${value.FullyDecoratedClassName()}::setFrom(other);
      }${#end}
    }

    ${#include "simple.compare.declaration.pattern"}

    std::string toString() const;

    friend std::ostream& operator<<(std::ostream& output, const ${class_name}& ${object_name});

    ${#include "simple.value.serialization.declaration.pattern"}

    // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW

    // ^^^--- END OF USER DEFINED CLASS ELEMENTS
};
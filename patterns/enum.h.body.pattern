class ${class_name}
{
  public:
    // type traits
    static constexpr const char* class_name = { "${"::".join(name.UppercaseCamelsNamespaces())}::${class_name}" };
    static constexpr bool is_compareable = { ${#if compareable}true${#else}false${#end} };
    static constexpr bool is_ordered = { ${#if ordered}true${#else}false${#end} };
    static constexpr bool size_in_bytes = { ${base_class_size} };

    // internal value type
    enum e${class_name} : ${base_class} 
    {
      ${format.comma_separated(["E_" + value.UPPERCASE_NAME() for value in values])}
    };

    static constexpr e${class_name} first_value = { E_${first_value} };
    static constexpr e${class_name} last_value = { E_${last_value} } ;

    constexpr ${class_name}(${class_name}::e${class_name} e_${object_name} = ${class_name}::first_value) noexcept
      : m_${object_name}(e_${object_name})
    {  }

    ${#include "simple.assignment.pattern"}
  
    ${#include "simple.compare.pattern"}
  
    ${#include "dump.declaration.pattern"}

    ${#include "integer.binary.serialization.pattern"}

  private:
    e${class_name} m_${object_name};

    static const char* m_${object_name}_names[];

    static e${class_name} convertTextToPossibleEnum(const std::string& text) noexcept;
};
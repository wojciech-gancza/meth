class ${class_name}
{
  public:
    // type traits
    ${#include "common.traits.pattern"}
    static constexpr bool size_in_bytes = { ${int_class_size} };

    // internal value type
    enum e${class_name} : ${int_class} 
    {
      ${format.comma_separated(["E_" + value.UPPERCASE_NAME() for value in values])}
    };

    static constexpr e${class_name} first_value = { ${first_value} };
    static constexpr e${class_name} last_value = { ${last_value} } ;

    ${#include "simple.construction.pattern"}

    e${class_name} get${class_name}AsEnum() const noexcept { return m_${object_name}; }
    ${int_class} get${class_name}AsInt() const noexcept { return m_${object_name}; }

    ${#include "simple.getters.setters.pattern"}

    ${#include "simple.compare.pattern"}

    ${#include "common.to.from.string.declaration.pattern"}

    ${#include "simple.value.serialization.pattern"}

  private:
    e${class_name} m_${object_name};

    static const char* m_${object_name}_names[];

    static e${class_name} convertTextToPossibleEnum(const std::string& text) noexcept;

    // -vvv YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW

    // -^^^ END OF USER DEFINED CLASS ELEMENTS
};
${#for value in values}
constexpr ${class_name} ${value.UPPERCASE_NAME()} { ${class_name}(${class_name}::E_${value.UPPERCASE_NAME()}) };${#end}

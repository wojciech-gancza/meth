class ${class_name}
{
  public:
    // type traits
    ${#include "common.traits.pattern"}
    static constexpr bool size_in_bytes = { ${int_class_size} };
    static constexpr ${int_class} first_flag_value = { ${first_value} };
    static constexpr ${int_class} last_flag_value = { ${last_value} } ;

    // flags values (internal)
    enum e${class_name} : ${int_class}
    {
      ${format.bitmasks_enum(["E_" + value.UPPERCASE_NAME() for value in values])}
    };

    ${#include "simple.construction.pattern"}
  
    ${int_class} get${class_name}AsInt() const noexcept { return m_${object_name}; }

    ${#include "simple.getters.setters.pattern"}

    ${#include "simple.compare.pattern"}
    
    operator bool() const
    {
      return m_${object_name} != 0;
    }
    
    ${class_name} operator!() const noexcept
    {
      return ${class_name}(m_${object_name} ^ (2 * last_flag_value - 1));
    }

    ${class_name} operator|=(const ${class_name}& ${object_name}) noexcept
    {
      m_${object_name} |= ${object_name}.m_${object_name};
      return *this;
    }

    ${class_name} operator|(const ${class_name}& ${object_name}) const noexcept
    {
      return ${class_name}(m_${object_name} | ${object_name}.m_${object_name});
    }

    ${class_name} operator&=(const ${class_name}& ${object_name}) noexcept
    {
      m_${object_name} &= ${object_name}.m_${object_name};
      return *this;
    }

    ${class_name} operator&(const ${class_name}& ${object_name}) const noexcept
    {
      return ${class_name}(m_${object_name} & ${object_name}.m_${object_name});
    }

    bool isAnyOf${class_name}(const ${class_name}& ${object_name}) const noexcept
    {
      return (${object_name}.m_${object_name} & m_${object_name});
    }

    bool hasAllOf${class_name}(const ${class_name}& ${object_name}) const noexcept
    {
      return (${object_name}.m_${object_name} & m_${object_name}) == ${object_name}.m_${object_name};
    }

    void remove${class_name}(const ${class_name}& ${object_name}) noexcept
    {
      m_${object_name} &= ~${object_name}.m_${object_name};
    }

    ${#include "common.to.from.string.declaration.pattern"}

    ${#include "simple.value.serialization.pattern"}

  private:
    ${int_class} m_${object_name};

    static const char* m_${object_name}_bits_names[];

    ${class_name}(${int_class} ${object_name})
      : m_${object_name}(${object_name})
    {  }

    static e${class_name} convertTextToSingleFlag(const std::string& text);
    static e${class_name} convertTextToPossibleFlag(const std::string& text) noexcept;
    static std::string convertSingleFlagToString(e${class_name} bit) noexcept;

    // vvv--- YOU CAN PUT ADDITIONAL CLASS ELEMENTS BELOW

    // ^^^--- END OF USER DEFINED CLASS ELEMENTS
};
${#for value in values}
constexpr ${class_name} ${value.UPPERCASE_NAME()} { ${class_name}(${class_name}::E_${value.UPPERCASE_NAME()}) };${#end}

// vvv--- YOU CAN PUT ADDITIONAL DEFINITIONS BELOW

// ^^^--- END OF USER DEFINED DEFINITIONS

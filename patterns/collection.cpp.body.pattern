${#if compareable}bool ${class_name}::operator==(const ${class_name}& ${object_name}) const noexcept 
{
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator my_${item_object_name} = m_${object_name}.begin();
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator other_${item_object_name} = ${object_name}.m_${object_name}.begin();
  while ( my_${item_object_name} != m_${object_name}.end() && other_${item_object_name} != ${object_name}.m_${object_name}.end() )
  {
    if (!( *my_${item_object_name} == *other_${item_object_name} ))
    {
      return false;
    }
    ++my_${item_object_name};
    ++other_${item_object_name};
  }
  if (my_${item_object_name} == m_${object_name}.end() || other_${item_object_name} == ${object_name}.m_${object_name}.end())
  {
    return true;
  }
  else
  {
    return false;
  }
}

bool ${class_name}::operator!=(const ${class_name}& ${object_name}) const noexcept  
{
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator my_${item_object_name} = m_${object_name}.begin();
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator other_${item_object_name} = ${object_name}.m_${object_name}.begin();
  while ( my_${item_object_name} != m_${object_name}.end() && other_${item_object_name} != ${object_name}.m_${object_name}.end() )
  {
    if ( *my_${item_object_name} != *other_${item_object_name} )
    {
      return true;
    }
    ++my_${item_object_name};
    ++other_${item_object_name};
  }
  if (my_${item_object_name} == m_${object_name}.end() || other_${item_object_name} == ${object_name}.m_${object_name}.end())
  {
    return false;
  }
  else
  {
    return true;
  }
}
${#else}// No compare operators${#end}
${#if ordered}bool ${class_name}::operator<(const ${class_name}& ${object_name}) const noexcept 
{
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator my_${item_object_name} = m_${object_name}.begin();
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator other_${item_object_name} = ${object_name}.m_${object_name}.begin();
  while ( my_${item_object_name} != m_${object_name}.end() && other_${item_object_name} != ${object_name}.m_${object_name}.end() )
  {
    if ( *my_${item_object_name} < *other_${item_object_name} )
    {
      return true;
    }
    if ( *my_${item_object_name} != *other_${item_object_name} )
    {
      return false;
    }
    ++my_${item_object_name};
    ++other_${item_object_name};
  }
  if (my_${item_object_name} == m_${object_name}.end() || other_${item_object_name} == ${object_name}.m_${object_name}.end())
  {
    return false;
  }
  else
  {
    if (my_${item_object_name} != m_${object_name}.end())
    {
       return false;
    }
    else
    {
      return true;
    }
  }
}

bool ${class_name}::operator<=(const ${class_name}& ${object_name}) const noexcept 
{
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator my_${item_object_name} = m_${object_name}.begin();
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator other_${item_object_name} = ${object_name}.m_${object_name}.begin();
  while ( my_${item_object_name} != m_${object_name}.end() && other_${item_object_name} != ${object_name}.m_${object_name}.end() )
  {
    if ( *my_${item_object_name} < *other_${item_object_name} )
    {
      return true;
    }
    if ( *my_${item_object_name} != *other_${item_object_name} )
    {
      return false;
    }
    ++my_${item_object_name};
    ++other_${item_object_name};
  }
  if (my_${item_object_name} == m_${object_name}.end() || other_${item_object_name} == ${object_name}.m_${object_name}.end())
  {
    return true;
  }
  else
  {
    if (my_${item_object_name} != m_${object_name}.end())
    {
       return false;
    }
    else
    {
      return true;
    }
  }
}

bool ${class_name}::operator>=(const ${class_name}& ${object_name}) const noexcept 
{
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator my_${item_object_name} = m_${object_name}.begin();
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator other_${item_object_name} = ${object_name}.m_${object_name}.begin();
  while ( my_${item_object_name} != m_${object_name}.end() && other_${item_object_name} != ${object_name}.m_${object_name}.end() )
  {
    if ( *my_${item_object_name} > *other_${item_object_name} )
    {
      return true;
    }
    if ( *my_${item_object_name} != *other_${item_object_name} )
    {
      return false;
    }
    ++my_${item_object_name};
    ++other_${item_object_name};
  }
  if (my_${item_object_name} == m_${object_name}.end() || other_${item_object_name} == ${object_name}.m_${object_name}.end())
  {
    return true;
  }
  else
  {
    if (my_${item_object_name} != m_${object_name}.end())
    {
       return true;
    }
    else
    {
      return false;
    }
  }
}

bool ${class_name}::operator>(const ${class_name}& ${object_name}) const noexcept 
{
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator my_${item_object_name} = m_${object_name}.begin();
  std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator other_${item_object_name} = ${object_name}.m_${object_name}.begin();
  while ( my_${item_object_name} != m_${object_name}.end() && other_${item_object_name} != ${object_name}.m_${object_name}.end() )
  {
    if ( *my_${item_object_name} > *other_${item_object_name} )
    {
      return true;
    }
    if ( *my_${item_object_name} != *other_${item_object_name} )
    {
      return false;
    }
    ++my_${item_object_name};
    ++other_${item_object_name};
  }
  if (my_${item_object_name} == m_${object_name}.end() || other_${item_object_name} == ${object_name}.m_${object_name}.end())
  {
    return false;
  }
  else
  {
    if (my_${item_object_name} != m_${object_name}.end())
    {
       return true;
    }
    else
    {
      return false;
    }
  }
}${#else}// No ordering operators${#end}

void ${class_name}::remove${item_class_name}(const Iterator& ${item_object_name})
{
  m_${object_name}.erase(${item_object_name}); 
}

void ${class_name}::remove${class_name}(const SearchResult& items_to_delete)
{
  for (SearchResult::ReverseIterator item = items_to_delete.get${class_name}ReverseBegin(); item != items_to_delete.get${class_name}ReverseEnd(); ++item)
  {
    remove${item_class_name}(item.getIteratorToNodes());
  }
}

${#include "common.to.string.pattern" "class_name": class_name+"::SearchResult"}

${#include "collection.out.operator.pattern" "class_name": class_name+"::SearchResult", "name_decorator": ""}

${#include "common.to.string.pattern" "class_name": class_name+"::ConstSearchResult"}

${#include "collection.out.operator.pattern" "class_name": class_name+"::ConstSearchResult", "name_decorator": "Const"}

${class_name}& ${class_name}::operator+=(const ${class_name}& ${object_name})
{
  for (${class_name}::ConstIterator ${item_class_name} = ${object_name}.get${class_name}Begin(); ${item_class_name} != ${object_name}.get${class_name}End(); ++${item_class_name})
  {
    insert${item_class_name}(*${item_class_name});
  }
  return *this;
}

${#include "common.to.string.pattern"}

std::ostream& operator<<(std::ostream& output, const ${class_name}& ${object_name})
{
  output << "[ ";
  const char* separator = "";
  for (std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator ${item_object_name} = ${object_name}.m_${object_name}.begin(); ${item_object_name} != ${object_name}.m_${object_name}.end(); ++${item_object_name})
  {
    output << separator << *${item_object_name};
    separator = ", ";
  }

  output << " ]";
  return output;
}
${#if serializable}
Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& serializer, const ${class_name}& ${object_name})
{
  ${int_class} count_of_items = ${object_name}.get${class_name}Count();
  serializer.storeValue(count_of_items);
  for (std::vector<${element_type.FullyDecoratedClassName()}>::const_iterator ${item_object_name} = ${object_name}.m_${object_name}.begin(); ${item_object_name} != ${object_name}.m_${object_name}.end(); ++${item_object_name})
  {
    serializer << *${item_object_name};
  }
  return serializer;
}

Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& deserializer, ${class_name}& ${object_name})
{
  ${int_class} count_of_items = 0;
  deserializer.readValue(count_of_items);
  ${object_name}.m_${object_name}.clear();
  ${element_type.FullyDecoratedClassName()} ${item_object_name};
  for (${int_class} item_number = 0; item_number < count_of_items; ++item_number)
  {
    deserializer >> ${item_object_name};
    ${object_name}.insert${item_class_name}(${item_object_name});
  }
  return deserializer;
}
${#end}
// vvv--- YOU CAN PUT ADDITIONAL CODE BELOW

// ^^^--- END OF USER DEFINED CODE

std::string ${class_name}::toString() const
{
  std::ostringstream buffer; 
  buffer << "\"";
  for (std::string::const_iterator character_ptr = m_${object_name}.begin(); character_ptr != m_${object_name}.end(); ++character_ptr)
  {
    switch(*character_ptr)
    {
      case '\'':
      case '\"':
      case '\\':
        buffer << '\\';
      default:
        buffer << *character_ptr;
    }
  }
  buffer << "\"";
  return buffer.str();
}

Serialization::BinarySerializer& operator<<(Serialization::BinarySerializer& serializer, const ${class_name}& ${object_name})
{
  ${int_class} count_of_bytes = ${object_name}.get${class_name}Length();
  serializer.storeValue(count_of_bytes);
  for (std::string::const_iterator character_ptr = ${object_name}.m_${object_name}.begin(); character_ptr != ${object_name}.m_${object_name}.end(); ++character_ptr)
  {
    serializer.storeByte(*character_ptr);
  }
  return serializer;
}

Serialization::BinaryDeserializer& operator>>(Serialization::BinaryDeserializer& deserializer, ${class_name}& ${object_name})
{
  ${int_class} count_of_bytes;
  deserializer.readValue(count_of_bytes);
  std::string result(count_of_bytes, ' ');
  for (${int_class} position = 0; position < count_of_bytes; ++position)
  {
    deserializer.readByte(reinterpret_cast<uint8_t&>(result[position]));
  }
  ${object_name}.set${class_name}(result);
  return deserializer;
}
 
// vvv--- YOU CAN PUT ADDITIONAL DEFINITIONS BELOW

// ^^^--- END OF USER DEFINED DEFINITIONS
